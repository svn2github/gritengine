// need to do these in fragment shader, to stop the sun vanishing at
// the corners of the screen

val pos_ss_ = frag.screen.xy/global.viewportSize.xy*2-1;

// TODO: figure out this d3d9 business
//pos_ss_.y *= -d3d9();

// CLOUDS
val perlin_uv = 5*uv;
val cloud_dist = length(perlin_uv) / 4.5;

val cloud_anim = Float4(0.01, 0.01, 0.02, 0.02);
val clouduv1 = (global.time * cloud_anim.xy + perlin_uv.xy)/5;
val clouduv2 = (global.time * cloud_anim.zw + perlin_uv.yx)/5;
val clouduv3 = (global.time * cloud_anim.xy + perlin_uv.xy)*5;

val cloud_atten = clamp(1-cloud_dist*cloud_dist, 0.0, 1.0);
val cloud_tex1 = sample2D(mat.perlin, clouduv1).r;
val cloud_tex2 = sample2D(mat.perlin, clouduv2).r;
val cloud_tex3 = sample2D(mat.perlin, clouduv3).r;

val cloud_blend = 0.48*cloud_tex1 + 0.48*cloud_tex2 + 0.04*cloud_tex3;
val cloud = clamp((cloud_blend - (1-global.skyCloudCoverage)) / global.skyCloudCoverage,
                  0.0, 1.0);
val murkyness = clamp(cloud*2.0 - 0.2, 0.0, 1.0) * 0.6;

val cloud_ntex1 = sample2D(mat.perlinN, clouduv1).rgb*2 - 1;
val cloud_ntex2 = sample2D(mat.perlinN, clouduv2).grb*2 - 1;
val cloud_ntex3 = sample2D(mat.perlinN, clouduv3).rgb*2 - 1;
val cloud_n = normalize(0.48*cloud_ntex1 + 0.48*cloud_ntex2 + 0.04*cloud_ntex3);

val sun_uv = Float2(pos_ss_ - sunlight_dir_ss.xy);
val sun_distance = sqrt(dot(sun_uv,sun_uv)) * (fov.x+fov.y)/2;
var sun_cloud_dome_pos = Float3(
    4.51*cos(sun_pos_ss_polar_y/180*PI)
    * Float2(sin(sun_pos_ss_polar_x/180*PI), cos(sun_pos_ss_polar_x/180*PI)),
    4.51*sin(sun_pos_ss_polar_y/180*PI));
if (sun_cloud_dome_pos.z<0) sun_cloud_dome_pos.z = sun_cloud_dome_pos.z * -1;
val cloud_dome_pos = Float3(perlin_uv, 0.3);
val cloud_sun_dir = normalize(sun_cloud_dome_pos - cloud_dome_pos);
val emboss = lerp(dot(cloud_n, cloud_sun_dir), 1.0, 0.5);
frag.colour.rgb = emboss * global.skyCloudColour * cloud_atten * cloud;
frag.colour.a = cloud_atten * cloud;

