val aspect = g.viewportSize.x / g.viewportSize.y;
val fov_x = aspect * g.fovY;

// The world matrix encodes only sky orientation data (i.e. due to the rotation of the earth).
out.position = mul(g.worldViewProj, float4(in.position.xyz,0));

// hack our way to maximum depth
out.position.z = out.position.w * (1 - 1.0/65536); // avoid 'black lightning' artifacts

val sunlight_dir_ss_ = mul(g.viewProj, float4(-g.sunDirection, 1));

// for interpolators
val uv = in.texcoord0.xy;
val sunlight_dir_ss = sunlight_dir_ss_.xyz/sunlight_dir_ss_.w;
val fov = float2(fov_x, su_fovY);
val sun_pos_ss_polar_x = mod(atan2(-su_sunDirection.x, -su_sunDirection.y)/PI/2 + 1, 1) * 360;
val sun_pos_ss_polar_y = atan(-su_sunDirection.z / sqrt(dot(su_sunDirection.xy, su_sunDirection.xy))) / PI * 180;

