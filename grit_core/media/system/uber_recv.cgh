// (c) David Cunningham 2012, Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php

#if BLEND <= 1
    #define BLENDSZ 1
#else
    #define BLENDSZ 4
#endif

#if RENDER_OBJECT_NORMAL==1 || RENDER_NORMAL==1 || RENDER_TANGENT==1
    #define ABUSING_DIFFUSE 1
#else
    #define ABUSING_DIFFUSE 0
#endif

#if USE_DIFFUSE_MAP==1 || USE_NORMAL_MAP==1 || USE_GLOSS_MAP==1 || USE_TRANSLUCENCY_MAP==1 || USE_PAINT_MAP==1
    #define USE_SOME_MAP 1
#else
    #define USE_SOME_MAP 0
#endif



// {{{ punctual lighting equations

float3 punctual_lighting (
    float3 light_diff,
    float3 light_spec,
    float3 surf_diff,
    float surf_spec,
    float surf_gloss,
    float3 surf_normal,
    float3 surf_to_cam,
    float3 surf_to_light
) {
    float3 surf_to_half = normalize(0.5*(surf_to_cam + surf_to_light));

    // diffuse component
    float3 diff_component = light_diff * surf_diff;

    // specular component
    float3 fresnel = surf_spec + (1-surf_spec) * strength(1.0 - dot(surf_to_light, surf_to_half), 5);
    float gloss = pow(4096.0, surf_gloss); // guesswork here
    float3 highlight = 1.0/8 * (gloss+2) * strength(dot(surf_normal, surf_to_half), gloss);
    float3 spec_component = light_spec * fresnel * highlight;

    float3 pixel_colour = (spec_component + diff_component) * max(0.0, dot(surf_normal, surf_to_light));

    #if RENDER_DIFFUSE_TERM==1
            pixel_colour = zero(pixel_colour) + diff_component * max(0.0, dot(surf_normal, surf_to_light));
    #endif
    #if RENDER_SPECULAR_TERM==1
            pixel_colour = zero(pixel_colour) + spec_component * max(0.0, dot(surf_normal, surf_to_light));;
    #endif

    #if RENDER_HIGHLIGHT==1
            pixel_colour = zero(pixel_colour) + highlight;
    #endif
    #if RENDER_FRESNEL==1
            pixel_colour = zero(pixel_colour) + fresnel;
    #endif
    #if RENDER_FRESNEL_HIGHLIGHT==1
            pixel_colour = zero(pixel_colour) + fresnel * highlight;
    #endif

    #if RENDER_DIFFUSE_COMPONENT==1
            pixel_colour = zero(pixel_colour) + diff_component;
    #endif
    #if RENDER_SPECULAR_COMPONENT==1
            pixel_colour = zero(pixel_colour) + spec_component;
    #endif


    return pixel_colour;
}

float3 punctual_lighting_old (
    float3 light_diff,
    float3 light_spec,
    float3 surf_diff,
    float surf_spec,
    float surf_gloss,
    float3 surf_normal,
    float3 surf_to_cam,
    float3 surf_to_light
) {
        float3 diff_component = surf_diff * light_diff * max(0.0, dot(surf_normal, surf_to_light));
        float3 spec_component = surf_spec * light_spec * strength(dot(reflect(-surf_to_cam, surf_normal), surf_to_light), surf_gloss*255);
        return diff_component + spec_component;
}

// }}}



#if FORWARD_PART==1

// {{{ factored out forward rendering part
void forward_pass (
        float3 vertex_colour, float vertex_alpha,
        float face,
        float3 surf_diffuse, float surf_alpha, float surf_specular, float surf_gloss,
        float alpha_rej,
        float4 time,
        float4 col1, float4 col2, float4 col3, float4 col4,
        float3 col_spec1, float3 col_spec2, float3 col_spec3, float3 col_spec4,
        float microflakes_mask,
        #if USE_MICROFLAKES==1
        float3 pos_os,
        #endif
        float render_target_flipping,
        float contrast,
        #if USE_NORMAL_MAP==1
        float3 tangent_ns,
        float tangent_parity,
        #endif
        float blend[BLENDSZ],
        float visibility,
        float2 screen_pos,
        float3 texture_size,

        EXTRA_MAPS_AGAIN

        BLEND_UNIFORMS

        inout float3 diff_colour,
        inout float3 normal_ns,
        inout float specular,
        inout float gloss,
        inout float translucency,
        inout float pixel_alpha
) {
        // {{{ texture coordinates
        float2 uv[BLEND] = { UVS };
        float2 uv_scale[BLEND] = { UV_SCALES };
        float2 uv_animation[BLEND] = { UV_ANIMATIONS };
        float2 uv_ddx[BLEND];
        float2 uv_ddy[BLEND];

        for (int i=0 ; i<BLEND ; ++i) {
                uv[i] *= uv_scale[i];
                uv[i] += time.x*uv_animation[i];
                uv_ddx[i] = ddx(uv[i]);
                uv_ddy[i] = ddy(uv[i]);
        }
        // }}}

        // {{{ blend (heightmap) and diffuse

        // Assuming a maximum height, we test what the contribution could be.
        // If this is below zero then it is impossible to suppress the
        // 'highest' texture, even if our height turns out to be maximum and
        // the competition is minimum.  This means we can omit the texture fetch.
/*
        float max_contribution[BLEND];
        {
                // biggest blend factor (without including height)
                float highest = 0;
                for (int i=0 ; i<BLEND ; ++i) {
                        highest = max(highest, blend[i]);
                }

                for (int i=0 ; i<BLEND ; ++i) {
                        max_contribution[i] = max(0, highest + (blend[i] + 255.0/256/2 - highest)*contrast);
                }
                float total = max_contribution[0];
                for (int i=1 ; i<BLEND ; ++i) {
                        total += max_contribution[i];
                }
                total = 1/total;
                for (int i=0 ; i<BLEND ; ++i) {
                        max_contribution[i] *= total;
                }
        }
*/


        pixel_alpha = vertex_alpha * surf_alpha;
        #if USE_DIFFUSE_MAP==1
        float4 diff_txl[BLEND];
                {
                        sampler2D diffs[BLEND] = { DIFFUSE_MAPS };
                        for (int i=0 ; i<BLEND ; ++i) {
                                //if (NO_OPTIMISE || d3d9()>0 || max_contribution[i] > 0) {
                                        diff_txl[i] = tex2D(diffs[i], uv[i], uv_ddx[i], uv_ddy[i]);
                                //} else {
                                //        diff_txl[i] = float4(0,0,0,0);
                                //}
                        }
                }
                #if BLEND==1
                        pixel_alpha *= diff_txl[0].a;
                        #if PREMULTIPLIED_ALPHA==1
                        diff_txl[0].rgb = clamp(diff_txl[0].rgb/diff_txl[0].a, 0.0, 1.0);
                        #endif
                #endif
        #endif
        if (pixel_alpha <= alpha_rej) discard;

        #if USE_HEIGHTMAP_BLENDING==1 && USE_DIFFUSE_MAP==1 && BLEND > 1
                // include height
                for (int i=0 ; i<BLEND ; ++i) {
                        blend[i] += diff_txl[i].a * 255/256.0/2;
                }
        #endif


        // contribution of each texture to the mix (including height)
        float contribution[BLEND];
        #if USE_HEIGHTMAP_BLENDING==1
        {
                float highest = blend[0];
                // biggest blend factor (including height)
                for (int i=1 ; i<BLEND ; ++i) {
                        highest = max(highest, blend[i]);
                }
                float tmp = highest - highest * contrast;
                for (int i=0 ; i<BLEND ; ++i) {
                        contribution[i] = max(0.0, blend[i] * contrast + tmp);
                }
                float total = contribution[0];
                for (int i=1 ; i<BLEND ; ++i) {
                        total += contribution[i];
                }
                total = 1/total;
                for (int i=0 ; i<BLEND ; ++i) {
                        contribution[i] *= total;
                }
        }
        #else
        {
                float rem = 1;
                for (int i=1 ; i<BLEND ; ++i) {
                        contribution[i] = blend[i];
                        rem -= blend[i];
                }
                contribution[0] = rem;
        }
        #endif

        #if USE_DIFFUSE_MAP==1
        float4 diff_blend;
                for (int i=0 ; i<BLEND ; ++i) {
                        //if (contribution[i] > 0) {
                                diff_txl[i].rgb *= contribution[i];
                        //} else {
                        //        diff_txl[i].rgb = float3(0,0,0);
                        //}
                }
                diff_blend = diff_txl[0];
                for (int i=1 ; i<BLEND ; ++i) {
                        diff_blend += diff_txl[i];
                }
        #endif

        // }}}

        #if USE_NORMAL_MAP==1
        float3 norm_blend;
        {
                sampler2D norms[BLEND] = { NORMAL_MAPS };
                float3 norm_txl[BLEND];
                for (int i=0 ; i<BLEND ; ++i) {
                        //if (NO_OPTIMISE || d3d9()>0 || contribution[i]>0) {
                                norm_txl[i] = tex2D(norms[i], uv[i], uv_ddx[i], uv_ddy[i]).rgb;
                                norm_txl[i] *= contribution[i];
                        //}
                }
                norm_blend = norm_txl[0];
                for (int i=1 ; i<BLEND ; ++i) {
                        norm_blend += norm_txl[i];
                }
        }
        #endif

        #if USE_GLOSS_MAP==1
        float3 spec_blend;
        {
                sampler2D specs[BLEND] = { SPEC_MAPS };
                float3 spec_txl[BLEND];
                for (int i=0 ; i<BLEND ; ++i) {
                        //if (NO_OPTIMISE || d3d9()>0 || contribution[i]>0) {
                                spec_txl[i] = tex2D(specs[i], uv[i], uv_ddx[i], uv_ddy[i]).rgb;
                                spec_txl[i] *= contribution[i];
                        //}
                }
                spec_blend = spec_txl[0];
                for (int i=1 ; i<BLEND ; ++i) {
                        spec_blend += spec_txl[i];
                }
        }
        #endif

        #if USE_TRANSLUCENCY_MAP==1
        float4 tran_blend;
        {
                sampler2D trans[BLEND] = { TRAN_MAPS };
                float4 tran_txl[BLEND];
                for (int i=0 ; i<BLEND ; ++i) {
                        //if (NO_OPTIMISE || d3d9()>0 || contribution[i]>0) {
                                tran_txl[i] = tex2D(trans[i], uv[i], uv_ddx[i], uv_ddy[i]);
                                tran_txl[i] *= contribution[i];
                        //}
                }
                tran_blend = tran_txl[0];
                for (int i=1 ; i<BLEND ; ++i) {
                        tran_blend += tran_txl[i];
                }
        }
        #endif

        #if USE_PAINT_MAP==1
        float4 paint_blend = FAKEtex2D(paint_map, uv[0], uv_ddx[0], uv_ddy[0]);
        #endif


        #if USE_NORMAL_MAP==1
                float3 normal_ts = float3(-2,2,2)*(norm_blend.xyz - .5);
        #endif
        #if FLIP_BACKFACE_NORMALS==1
        normal_ns *= process_face(render_target_flipping, face);
        #endif
        #if USE_NORMAL_MAP==1
                float3 binormal_ns = tangent_parity * cross(normal_ns, tangent_ns);
                normal_ns = normal_ts.x*tangent_ns + normal_ts.y*binormal_ns + normal_ts.z*normal_ns;
        #endif



        // compute diffuse surface colour
        #if USE_DIFFUSE_MAP==1
                float3 diff_texture_colour = gamma_decode(diff_blend.rgb);
        #else
                float3 diff_texture_colour = float3(1,1,1);
        #endif
        #if USE_GLOSS_MAP==1
                float gloss_texture = spec_blend.b;
                #if USE_SPECULAR_FROM_GLOSS == 1
                    float spec_texture = gamma_decode(spec_blend.r);
                #else
                    float spec_texture = 1; // presuambly masked by material attributes
                #endif
        #else
                float spec_texture = 1; // presuambly masked by material attributes
                float gloss_texture = 1; // presuambly masked by material attributes
        #endif

        // blend in the colours
        #if USE_PAINT_MAP==1
                float3 colourised = paint_blend.r*col1.rgb + paint_blend.g*col2.rgb + paint_blend.b*col3.rgb + (1-paint_blend.a)*col4.rgb;
                float colourised_met = paint_blend.r*col1.a + paint_blend.g*col2.a + paint_blend.b*col3.a + (1-paint_blend.a)*col4.a;
                float colourised_spec = paint_blend.r*col_spec1.r + paint_blend.g*col_spec2.r + paint_blend.b*col_spec3.r + (1-paint_blend.a)*col_spec4.r;
                float colourised_gloss = paint_blend.r*col_spec1.b + paint_blend.g*col_spec2.b + paint_blend.b*col_spec3.b + (1-paint_blend.a)*col_spec4.b;
        #elif USE_PAINT_COLOUR==1
                float3 colourised = col1.rgb;
                float colourised_met = col1.a;
                float colourised_spec = col_spec1.r;
                float colourised_gloss = col_spec1.b;
        #elif USE_PAINT_COLOUR==2
                float3 colourised = col2.rgb;
                float colourised_met = col2.a;
                float colourised_spec = col_spec2.r;
                float colourised_gloss = col_spec2.b;
        #elif USE_PAINT_COLOUR==3
                float3 colourised = col3.rgb;
                float colourised_met = col3.a;
                float colourised_spec = col_spec3.r;
                float colourised_gloss = col_spec3.b;
        #elif USE_PAINT_COLOUR==4
                float3 colourised = col4.rgb;
                float colourised_met = col4.a;
                float colourised_spec = col_spec4.r;
                float colourised_gloss = col_spec4.b;
        #endif
        #if USE_PAINT_ALPHA==1
                diff_texture_colour = lerp(colourised, diff_texture_colour, diff_blend.a);
                microflakes_mask *= lerp(colourised_met, 0, diff_blend.a);
                spec_texture = lerp(colourised_spec, spec_texture, diff_blend.a);
                gloss_texture = lerp(colourised_gloss, gloss_texture, diff_blend.a);
        #elif USE_PAINT_MASK==1
                diff_texture_colour *= colourised;
                microflakes_mask *= colourised_met;
                spec_texture *= colourised_spec;
                gloss_texture *= colourised_gloss;
        #endif

        #if USE_TRANSLUCENCY_MAP==1
                translucency = tran_blend.r;
        #else
                translucency = 0;
        #endif

        #if USE_MICROFLAKES==1
                float scale = 16;
                float microflakes = tex2D(microflakes_map, float2(scale*pos_os.x, mod(scale*pos_os.y, 1)/32 + floor(scale*pos_os.z*32)/32 )).r;
                microflakes = pow(microflakes,3);
                gloss_texture -= microflakes_mask * microflakes;
                spec_texture = lerp(spec_texture, 0.3, microflakes_mask * microflakes);
        #endif
        diff_colour = surf_diffuse * diff_texture_colour * gamma_decode(vertex_colour);
        specular = surf_specular * spec_texture;
        gloss = surf_gloss * gloss_texture;

        // fade out
        float v = visibility;
        #if WORLD_GEOMETRY==1
        // it seems that the rasteriser is a bit lossy, what goes in as 1.0 comes out a bit smaller
        v += 0.5/256;
        #endif

        #if USE_STIPPLE_TEXTURE==1
        if (v<1) {

                int x = (int(screen_pos.x) % 8);
                int y = (int(screen_pos.y) % 8);
                
                if (stipple(x,y,v,stipple_map)) discard;
        }
        #else
                pixel_alpha *= v;
        #endif

        //////////////////////////// DEBUG STUFF //////////////////////////////////////////////////////////


        #if RENDER_UV==1
                #if USE_SOME_MAP==1
                        diff_colour = zero(diff_colour) + float3(uv[0]-floor(uv[0]),0);
                #else
                        diff_colour = zero(diff_colour) + float3(0,0,1);
                #endif
        #endif

        #if RENDER_UV_STRETCH_BANDS==1
                #if USE_SOME_MAP==1
                        float stretchx = sqrt(dot(texture_size.xy*uv_ddx[0],texture_size.xy*uv_ddx[0]));
                        float stretchy = sqrt(dot(texture_size.xy*uv_ddy[0],texture_size.xy*uv_ddy[0]));
                        diff_colour = zero(diff_colour);
                        if (stretchx < 1.05 && stretchx > 0.95 && stretchy < 1.05 && stretchy > 0.95) {
                                diff_colour += float3(1,1,0);
                        } else if (stretchx < 1.05 && stretchx > 0.95) {
                                diff_colour += float3(1,0,0);
                        } else if (stretchy < 1.05 && stretchy > 0.95) {
                                diff_colour += float3(0,1,0);
                        }
                #else
                        diff_colour = zero(diff_colour) + zero(texture_size);
                #endif
        #endif
        #if RENDER_UV_STRETCH==1
                #if USE_SOME_MAP==1
                        float stretchx = sqrt(dot(texture_size.xy*uv_ddx[0],texture_size.xy*uv_ddx[0]));
                        float stretchy = sqrt(dot(texture_size.xy*uv_ddy[0],texture_size.xy*uv_ddy[0]));
                        float stretch = max(stretchx,stretchy);
                        diff_colour = zero(diff_colour) + float3(.01/stretch,1/stretch,0.1/stretch);

                #else
                        diff_colour = zero(diff_colour) + zero(texture_size);
                #endif
        #endif

        #if ABUSING_DIFFUSE==1
                diff_colour = zero(diff_colour) + surf_diffuse;
        #endif

        #if RENDER_VERTEX_COLOUR==1
                diff_colour = zero(diff_colour) + gamma_decode(vertex_colour) * float3(1,1,1);
        #endif

        #if RENDER_NORMAL_MAP==1 
                #if USE_NORMAL_MAP==1
                        diff_colour = zero(diff_colour) + norm_blend;
                #else
                        diff_colour = zero(diff_colour) + float3(0.5,0.5,1);
                #endif
        #endif

        #if RENDER_BINORMAL==1
                #if USE_NORMAL_MAP==1
                        diff_colour = zero(diff_colour) + direction_to_colour(binormal_ns);
                #else
                        diff_colour = zero(diff_colour) + float3(0.5,0.5,1);
                #endif
        #endif
}
// }}}

#endif


#if DEFERRED_AMBIENT_SUN_PART==1

// {{{ shadow test utilities
#if RECEIVE_SHADOWS == 1 

float tap_test (sampler2D tex, float2 uv, float our_dist)
{
        return our_dist > FAKEtex2D(tex, uv, 0.0, 0.0).r ? 1.0 : 0.0;
}

float pcf_tap_test (sampler2D tex, int sz, float2 uv, float d)
{
        #if EMULATE_PCF == 0
        return tap_test(tex,uv,d);
        #else
        uv *= sz;
        uv -= float2(0.5,0.5);
        float2 wh = floor(uv); // whole component
        float2 fr = uv - wh; // fractional component

        float t00 = tap_test(tex,(wh+float2(0.0,0.0))/sz,d);
        float t01 = tap_test(tex,(wh+float2(0.0,1.0))/sz,d);
        float t10 = tap_test(tex,(wh+float2(1.0,0.0))/sz,d);
        float t11 = tap_test(tex,(wh+float2(1.0,1.0))/sz,d);

        return lerp(lerp(t00, t01, fr.y), lerp(t10, t11, fr.y), fr.x);
        #endif
}

#if SHADOW_FILTER_NOISE == 1
float test_shadow (float3 pos_ls, sampler2D tex, sampler2D shadow_filter_noise, float our_dist, float spread, float2 screen_pos)
#else
float test_shadow (float3 pos_ls, sampler2D tex, float our_dist, float spread, float2 screen_pos)
#endif
{
        pos_ls.xy /= pos_ls.z;

        our_dist /= SHADOW_FACTOR;

        float total = 0;
        int samples = 0;

        int filter_taps_side = int(sqrt(float(SHADOW_FILTER_TAPS)));
        float half_filter_taps_side = filter_taps_side / 2.0;

        #if SHADOW_FILTER_NOISE == 1

                float2 noise_uv = screen_pos.xy / 64;
                float2 noise_texel = FAKEtex2D(shadow_filter_noise, noise_uv, 0.0, 0.0).rg;
                float2 noise_offset = (2*noise_texel-1); // length(offset) <= 1
                float2 fragment_uv_offset = 0.8 * noise_offset;

        #elif SHADOW_FILTER_DITHER == 1

                float2 dithered_offset;
                if ((int(screen_pos.x)%2)==1) {
                        if ((int(screen_pos.y)%2)==1) {
                                dithered_offset = float2( 1,  0);
                        } else {
                                dithered_offset = float2(-1,  0);
                        }
                } else {
                        if ((int(screen_pos.y)%2)==1) {
                                dithered_offset = float2( 0,  1);
                        } else {
                                dithered_offset = float2( 0, -1);
                        }
                }
                float2 fragment_uv_offset = 0.6 * dithered_offset;

        #else

                float2 fragment_uv_offset = float2(0,0);

        #endif

        fragment_uv_offset *= spread / filter_taps_side / SHADOW_RES;

        for (int y=0 ; y<filter_taps_side ; y++) {
                for (int x=0 ; x<filter_taps_side ; x++) {
                        float2 tap_uv = float2(x-half_filter_taps_side+0.5, y-half_filter_taps_side+0.5) * spread / SHADOW_RES;
                        tap_uv /= half_filter_taps_side;
                        total += pcf_tap_test(tex, SHADOW_RES, pos_ls.xy+fragment_uv_offset+tap_uv, our_dist);
                        samples++;
                }
        }

        return total / samples;
}

#endif // RECEIVE_SHADOWS
// }}}

// {{{ factored out lighting equation

float3 deferred_shading (
        float env_scale,
        float3 diff_colour,
        float3 normal_ws,
        float specular,
        float gloss,
        float translucency,
        float cam_dist,

        float3 sun_dir_ws,
        float3 camera_dir_ws,
        float shadow_oblique_cutoff,
        float sun_dist_,
        float2 screen_pos,

        SHADOW_MAPS
        ENV_MAPS

        float3 pos_ls1_,
        float3 pos_ls2_,
        float3 pos_ls3_,

        float3 sun_diffuse_colour,
        float3 sun_specular_colour,
        float fog_param,
        float3 fog_colour

) {

        // compute shadow (unshadowyness ranges from 1 (unshadowed) to 0 (fully shadowed)
        // artifacts in unshadowyness will occur if the poly is parallel to the sun
        // unshadowyness also fades away from the camera
        float unshadowyness = 1.0;
        float3 shadow_uv;
        #if RECEIVE_SHADOWS == 1
                float shadowyness = 0.0;
                if (cam_dist < SHADOW_DIST1) {
                        shadow_uv = float3(mod(pos_ls1_.xy/pos_ls1_.z,1),0);
                        #if SHADOW_FILTER_NOISE == 1
                        shadowyness = test_shadow(pos_ls1_, shadow_map1, shadow_filter_noise, sun_dist_, SPREAD1, screen_pos);
                        #else
                        shadowyness = test_shadow(pos_ls1_, shadow_map1, sun_dist_, SPREAD1, screen_pos);
                        #endif
                }
                else if (cam_dist < SHADOW_DIST2) {
                        shadow_uv = float3(mod(pos_ls2_.xy/pos_ls2_.z,1),1);
                        #if SHADOW_FILTER_NOISE == 1
                        shadowyness = test_shadow(pos_ls2_, shadow_map2, shadow_filter_noise, sun_dist_, SPREAD2, screen_pos);
                        #else
                        shadowyness = test_shadow(pos_ls2_, shadow_map2, sun_dist_, SPREAD2, screen_pos);
                        #endif
                }
                else if (cam_dist < SHADOW_DIST3) {
                        shadow_uv = float3(mod(pos_ls3_.xy/pos_ls3_.z,1),0);
                        #if SHADOW_FILTER_NOISE == 1
                        shadowyness = test_shadow(pos_ls3_, shadow_map3, shadow_filter_noise, sun_dist_, SPREAD3, screen_pos);
                        #else
                        shadowyness = test_shadow(pos_ls3_, shadow_map3, sun_dist_, SPREAD3, screen_pos);
                        #endif
                }

                float fade = SHADOW_FADE_END==SHADOW_FADE_START ? 1 : min(1.0, (SHADOW_FADE_END-cam_dist)/(SHADOW_FADE_END-SHADOW_FADE_START));
                shadowyness *= fade;
                shadowyness = max(shadow_oblique_cutoff, shadowyness);
                unshadowyness = max(0.0, 1 - shadowyness);
        #endif // RECEIVE_SHADOWS == 1

        float3 sun_light = punctual_lighting(sun_diffuse_colour, sun_specular_colour, diff_colour, specular, gloss, normal_ws, camera_dir_ws, sun_dir_ws);

        sun_light *= unshadowyness;

        float env_map_mipmaps = 9; // 512
        float3 reflect_ws = -reflect(camera_dir_ws, normal_ws);
        float3 env_ambient0 = 16*gamma_decode(texCUBElod(env_cube0, float4(reflect_ws, env_map_mipmaps-1)).rgb);
        float3 env_diff_light0 = 16*gamma_decode(texCUBElod(env_cube0, float4(normal_ws, env_map_mipmaps-1)).rgb);
        float3 env_spec_light0 = 16*gamma_decode(texCUBElod(env_cube0, float4(reflect_ws, (1-gloss)*env_map_mipmaps)).rgb);
        float3 env_ambient1 = 16*gamma_decode(texCUBElod(env_cube0, float4(reflect_ws, env_map_mipmaps-1)).rgb);
        float3 env_diff_light1 = 16*gamma_decode(texCUBElod(env_cube0, float4(normal_ws, env_map_mipmaps-1)).rgb);
        float3 env_spec_light1 = 16*gamma_decode(texCUBElod(env_cube0, float4(reflect_ws, (1-gloss)*env_map_mipmaps)).rgb);
        float3 env_ambient = lerp(env_ambient0, env_ambient1, 0);
        float3 env_diff_light = lerp(env_diff_light0, env_diff_light1, 0);
        float3 env_spec_light = lerp(env_spec_light0, env_spec_light1, 0);
        float3 env_diff_component = diff_colour * env_scale*env_diff_light;
        float3 env_spec_component = specular * env_scale*env_spec_light;
        float3 env_fresnel_component = gloss * strength(1.0 - dot(normal_ws, camera_dir_ws), 5) * env_ambient;
        float3 env_light = env_diff_component + env_spec_component + env_fresnel_component;

        float3 pixel_colour = sun_light + env_light;

        // exp2 fog
        #if USE_FOG==1
                pixel_colour = lerp(fog_colour, pixel_colour, fog_weakness(fog_param, cam_dist));
        #endif

        #if RENDER_NORMAL==1
                pixel_colour = zero(pixel_colour) + direction_to_colour(normal_ws);
        #endif

        #if RENDER_UNSHADOWYNESS==1
                pixel_colour = zero(pixel_colour) + float3(unshadowyness, unshadowyness, unshadowyness);
        #endif

        #if RENDER_DIFFUSE_COLOUR==1
                pixel_colour = zero(pixel_colour) + diff_colour;
        #endif
        #if RENDER_SPECULAR==1
                pixel_colour = zero(pixel_colour) + specular * float3(1,1,1);
        #endif

        #if RENDER_GLOSS==1
                // We would like the colour output in this debug mode to agree with the appearance of a glossmap in gimp/photoshop
                pixel_colour = zero(pixel_colour) + gamma_decode(gloss)*float3(1,1,1);
        #endif


        #if RENDER_ENV_DIFFUSE_LIGHT==1
                pixel_colour = zero(pixel_colour) + env_diff_light;
        #endif
        #if RENDER_ENV_SPECULAR_LIGHT==1
                pixel_colour = zero(pixel_colour) + env_spec_light;
        #endif

        #if RENDER_ENV_DIFFUSE_COMPONENT==1
                pixel_colour = zero(pixel_colour) + env_diff_component;
        #endif
        #if RENDER_ENV_SPECULAR_COMPONENT==1
                pixel_colour = zero(pixel_colour) + env_spec_component;
        #endif


        #if RENDER_OBJECT_NORMAL==1 || RENDER_NORMAL_MAP==1 || RENDER_TANGENT==1 || RENDER_BINORMAL==1 || RENDER_UV==1 || RENDER_UV_STRETCH==1 || RENDER_VERTEX_COLOUR==1
                pixel_colour = zero(pixel_colour) + diff_colour;
        #endif

        #if RENDER_UV_STRETCH_BANDS==1
                pixel_colour = lerp(pixel_colour, diff_colour, 0.5);
        #endif

        return pixel_colour;
}
// }}}

#endif


// dist assumed to be >= 0
float light_attenuation (float R, float dist)
{
        dist /= R;
        dist = min(1.0,dist);
        return 2*dist*dist*dist - 3*dist*dist + 1;
}



// {{{ split (2 bytes)
// assumes v is in the range 0 to 1 inclusive
// r.y may not be an integer -- if this matters then the caller should floor() it
float2 split_2bytes (float v)
{
        v *= 256*256 - 1;
        float2 r;
        r.x = floor(v / 256); // most significant
        r.y = (v - r.x * 256);  // least significant
        return r / 255;
}

float join_2bytes (float2 bytes)
{
        return 255.0 * (256.0*bytes.x + bytes.y) / (256*256 - 1);
}
// }}}


// {{{ split (3 bytes)
// assumes v is in the range 0 to 1 inclusive
// r.z may not be an integer -- if this matters then the caller should floor() it
float3 split_3bytes (float v)
{
        v *= (256.0*256.0*256.0 - 1);
        float3 r;
        r.x = floor(v / 256.0 / 256.0); // most significant
        r.y = floor((v - r.x * 256.0 * 256.0) / 256.0);  // middle significant
        r.z = (v - r.x * 256.0 * 256.0 - r.y * 256.0);  // least significant
        return r / 255.0;
}

float join_3bytes (float3 bytes)
{
        // for some reason if i do the *255.0 before the / (big thing) all hell breaks loose (d3d9 only)
        return 255.0 * (256.0*256.0*bytes.x + 256.0*bytes.y + bytes.z) / (256.0*256.0*256.0 - 1);
}
// }}}

#define USE_NORMAL_ENCODING 1
#if USE_NORMAL_ENCODING == 0
float4 encode_normal (float3 normal)
{
    return float4((normalize(normal)+float3(1,1,1))/float3(2,2,2)+float3(0.5,0.5,0.5)/255, 0);
}

float3 decode_normal (float4 encoded_normal)
{
    return normalize(encoded_normal.xyz * float3(2,2,2) - float3(1,1,1));
}
#elif USE_NORMAL_ENCODING == 1
float4 encode_normal (float3 normal)
{
    normal = normalize(normal);
    // range [0,1]
    float2 tmp = (normal.xy + float2(1,1))/2;
    //tmp = zero(tmp) + float2(1,0.5);
    // range [0,4096)
    float2 normal2 = tmp*4095;
    normal2 = int2(normal2);
    //normal2 = zero(normal2) + float2(4095,2048);
    // range [0,16)
    float2 hi2 = int2(normal2 / 256);
    // range [0,256)
    float2 low2 = normal2 - hi2*256;
    float hi_mixed = hi2.x + hi2.y*16;


    //low2 = float2(0,0);
    //hi_mixed = 136;
    //normal.z = 1;
    float4 r = float4(low2.x/255, low2.y/255, hi_mixed/255, normal.z >= 0.0 ? 1 : 0);

    // corresponds to float3(0,0,1);
    //r = zero(r) + float4(0,0,136/255.0,1);
    // corresponds to float3(1,0,0);
    //r = zero(r) + float4(1, 0.5, 143.0/255, 1.0);
    // corresponds to float3(0,1,0);
    //r = zero(r) + float4(0.0, 1, (8 + 15*16)/255.0, 1.0);


    return r;
}

float3 decode_normal (float4 encoded_normal)
{
    // corresponds to float3(0,0,1);
    //encoded_normal = zero(encoded_normal) + float4(0,0,(8*16+8)/255.0,1);
    // corresponds to float3(1,0,0);
    //encoded_normal = zero(encoded_normal) + float4(1, 0, 15.0/255,1);
    // corresponds to float3(0,1,0);
    //encoded_normal = zero(encoded_normal) + float4(0.0, 1, (8 + 15*16)/255.0, 1.0);

    // first, decode x and y from 24 bit representation

    // range: [0,256)
    float2 low2 = encoded_normal.xy * 255;

    // range: [0,256)
    float hi_mixed = encoded_normal.z * 255;

    // range: [0,16)
    float2 hi2;
    hi2.y = int(hi_mixed/16);
    hi2.x = hi_mixed - hi2.y*16;

    // range: [0,4096)
    float2 tmp = low2 + hi2*256;

    // range [-1,1]
    float3 normal;
    normal.xy = (tmp/4095) * float2(2,2) - float2(1,1);


    // finally, compute z of unit vector
    float up = encoded_normal.w*2 - 1;
    //up = one(up);
    normal.z = up*(sqrt(1 - min(1.0,normal.x*normal.x + normal.y*normal.y)));

    return normal;
}
#elif USE_NORMAL_ENCODING == 2
float4 encode_normal (float3 normal)
{
    normal = normalize(normal);
    return float4((normal.xy+float2(1,1))/2+float2(0.5,0.5)/255, 0, normal.z >= 0.0 ? 1 : 0);
}

float3 decode_normal (float4 encoded_normal)
{
    float3 normal;
    normal.xy = (encoded_normal.xy * 2) - 1;
    // finally, compute z of unit vector
    float up = encoded_normal.w*2 - 1;
    normal.z = up*(sqrt(max(0.0000001, 1 - dot(normal.xy, normal.xy))));
    return normal;
}
#endif


// {{{ pack/unpack for gbuffer
void pack_deferred (
        inout float4 texel0,
        inout float4 texel1,
        inout float4 texel2,

        in float shadow_oblique_cutoff,
        in float3 diff_colour,
        in float3 normal_ws,
        in float specular,
        in float cam_dist, // normalised
        in float gloss
) {
        
        float4 encoded_normal = encode_normal(normal_ws);

        texel0 = float4(split_3bytes(cam_dist), (shadow_oblique_cutoff*127 + encoded_normal.w*128)/255);
        texel1 = float4(encoded_normal.xyz, gloss);
        texel2 = float4(gamma_encode(diff_colour), gamma_encode(specular));
}

void unpack_deferred (
        in float4 texel0,
        in float4 texel1,
        in float4 texel2,

        out float shadow_oblique_cutoff,
        out float3 diff_colour,
        out float3 normal_ws,
        out float specular,
        out float cam_dist, // normalised
        out float gloss
) {
        cam_dist = join_3bytes(texel0.xyz);
        float up = 0;
        texel0.a *= 255;
        if (texel0.a >= 128) {
            texel0.a -= 128;
            up = 1;
        }
        shadow_oblique_cutoff = texel0.a/127;
        normal_ws = decode_normal(float4(texel1.xyz, up));
        diff_colour = gamma_decode(texel2.rgb);
        specular = gamma_decode(texel2.a);
        gloss = texel1.a;
}
// }}}

