// (c) David Cunningham 2011, Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php

#include <system/uber.cgh>
#include <system/uber_recv.cgh>

void vp_main (
    // from vertex buffer
    in float3 vert_pos : POSITION,

    // from instance buffer
    in float3 part_basis_x : TEXCOORD0,
    in float part_half_depth : TEXCOORD1,
    in float3 part_basis_z : TEXCOORD2,
    in float3 part_pos : TEXCOORD3,
    in float3 part_diffuse : TEXCOORD4,
    in float part_alpha : TEXCOORD5,
    in float3 part_emissive : TEXCOORD6,
    in float4 part_uv : TEXCOORD7,

    uniform float4x4 view_proj,
    uniform float3 particle_ambient,
    uniform float render_target_flipping,
    uniform float3 camera_pos_ws,

    out float3 deferred_uv : TEXCOORD0,
    out float3 colour : TEXCOORD1, // doesn't vary
    out float alpha : TEXCOORD2, // doesn't vary
    out float2 uv : TEXCOORD4,
    out float3 camera_to_fragment : TEXCOORD5,
    out float half_depth : TEXCOORD7,
    out float4 for_rasteriser : POSITION

) {
    float3 pos_ws = vert_pos.x * part_basis_x
                  + vert_pos.z * part_basis_z
                  + part_pos;

    for_rasteriser = mul(view_proj, float4(pos_ws, 1));

    deferred_uv = for_rasteriser.xyw;
    for_rasteriser.y *= render_target_flipping;

    colour = part_diffuse * particle_ambient + part_emissive;
    alpha = part_alpha;
    uv = vert_pos.xz / float2(2, -2) + float2(0.5, 0.5);
    uv = part_uv.xy + uv * (part_uv.zw - part_uv.xy);
    camera_to_fragment = pos_ws - camera_pos_ws;
    half_depth = part_half_depth;
}


void fp_main (
    in float3 deferred_uv : TEXCOORD0,
    in float3 colour : TEXCOORD1, // doesn't vary
    in float alpha : TEXCOORD2, // doesn't vary
    in float2 part_uv : TEXCOORD4,
    in float3 camera_to_fragment : TEXCOORD5,
    in float half_depth : TEXCOORD7,

    sampler2D gbuffer0 : register(s0),
    sampler2D ptex : register(s1),

    uniform float3 top_left_ray,
    uniform float3 top_right_ray,
    uniform float3 bottom_left_ray,
    uniform float3 bottom_right_ray,

    uniform float4 viewport_size,
    uniform float alpha_rej,

    out float4 pixel : COLOR0

) {
    float2 uv = deferred_uv.xy / deferred_uv.z;
    uv = uv * float2(0.5, -0.5) + float2(0.5, 0.5);
    float3 ray = lerp(lerp(top_left_ray, top_right_ray, uv.x),
                      lerp(bottom_left_ray, bottom_right_ray, uv.x),
                      uv.y);
    // hack to stop it 'shimmering' in d3d9
    if (d3d9() > 0) uv += 0.5 * viewport_size.zw; // zw is 1/w 1/h

    float shadow_oblique_cutoff;
    float3 surf_diff_colour;
    float3 normal_ws;
    float surf_specular;
    float normalised_cam_dist;
    float gloss;
    unpack_deferred(tex2D(gbuffer0, uv), float4(0, 0, 0, 0), float4(0, 0, 0, 0),
                    shadow_oblique_cutoff, surf_diff_colour, normal_ws, surf_specular, normalised_cam_dist, gloss);

    float scene_dist = length(normalised_cam_dist * ray);
    float fragment_dist = length(camera_to_fragment);
    float part_exposed = clamp((scene_dist - fragment_dist + half_depth)/half_depth, 0.0, 1.0);

    float4 texel = tex2D(ptex, part_uv);
    texel.a *= alpha;
    if (texel.a < alpha_rej) discard;
    texel.rgb = gamma_decode(texel.rgb);


    pixel = texel;
    pixel.rgb *= colour;

    pixel *= part_exposed;
}
