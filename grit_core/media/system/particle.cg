// (c) David Cunningham 2011, Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php

#include <system/uber.cgh>
#include <system/uber_recv.cgh>

void vp_main (
        // from vertex buffer
        in float3 vert_pos : POSITION,

        // from instance buffer
        in float3 part_basis_x : TEXCOORD0,
        in float3 part_basis_y : TEXCOORD1,
        in float3 part_basis_z : TEXCOORD2,
        in float3 part_pos : TEXCOORD3,
        in float3 part_colour : TEXCOORD4,
        in float part_alpha : TEXCOORD5,
        in float4 part_uv : TEXCOORD6,

        uniform float4x4 view_proj,
        uniform float3 particle_ambient,
        uniform float render_target_flipping,
        uniform float3 camera_pos_ws,

        out float3 deferred_uv : TEXCOORD0,
        out float3 colour : TEXCOORD1, // doesn't vary
        out float alpha : TEXCOORD2, // doesn't vary
        out float2 uv : TEXCOORD4,
        out float3 camera_to_fragment : TEXCOORD5,
        out float3 camera_to_fragment_front : TEXCOORD6,
        out float3 camera_to_part : TEXCOORD7, // doesn't vary
        out float4 for_rasteriser : POSITION

) {
        float3 pos_ws = vert_pos.x * part_basis_x
                      + vert_pos.z * part_basis_z;

        //pos_ws = zero(pos_ws) + vert_pos;
        pos_ws += part_pos;

        

        for_rasteriser = mul(view_proj, float4(pos_ws,1));

        deferred_uv = for_rasteriser.xyw;
        for_rasteriser.y *= render_target_flipping;
        float min_depth;
        if (d3d9() > 0) {
                // in d3d9, ensure z/w == 0
                min_depth = 0;
        } else {
                // in gl, ensure z/w is just above -1
                min_depth = -for_rasteriser.w + 1/30000.0;
        }
        //for_rasteriser.z = -for_rasteriser.w * 0.9;


        #if EMISSIVE==0
        part_colour *= particle_ambient;
        #endif

        colour = part_colour;
        alpha = part_alpha;
        uv = vert_pos.xz/2 + float2(0.5,0.5);
        uv.y = 1 - uv.y;
        uv = part_uv.xy + uv * (part_uv.zw - part_uv.xy);
        camera_to_fragment = pos_ws - camera_pos_ws;
        camera_to_part = part_pos - camera_pos_ws;
        camera_to_fragment_front = camera_to_fragment * max(0.0, length(camera_to_part) - length(part_basis_y))/length(camera_to_part);
}


void fp_main (
        in float3 deferred_uv : TEXCOORD0,
        in float3 colour : TEXCOORD1, // doesn't vary
        in float alpha : TEXCOORD2, // doesn't vary
        in float2 part_uv : TEXCOORD4,
        in float3 camera_to_fragment : TEXCOORD5,
        in float3 camera_to_fragment_front : TEXCOORD6,
        in float3 camera_to_part : TEXCOORD7,

        sampler2D gbuffer0 : register(s0),
        sampler2D ptex : register(s1),

        uniform float3 top_left_ray,
        uniform float3 top_right_ray,
        uniform float3 bottom_left_ray,
        uniform float3 bottom_right_ray,

        uniform float3 the_fog_colour,
        uniform float4 the_fog_params,
        uniform float3 camera_pos_ws,
        uniform float far_clip_distance,
        uniform float4 viewport_size,
        uniform float alpha_rej,

        out float4 pixel : COLOR0

) {


        float2 uv = deferred_uv.xy/deferred_uv.z;
        uv = uv * float2(0.5,-0.5) + float2(0.5,0.5);
        float3 ray = lerp(lerp(top_left_ray,top_right_ray, uv.x),
                          lerp(bottom_left_ray,bottom_right_ray, uv.x),
                          uv.y);
        // hack to stop it 'shimmering' in d3d9
        if (d3d9() > 0) uv += 0.5 * viewport_size.zw; // zw is 1/w 1/h

        float shadow_oblique_cutoff;
        float3 surf_diff_colour;
        float3 normal_ws;
        float surf_specular;
        float normalised_cam_dist;
        float gloss;
        unpack_deferred(tex2D(gbuffer0, uv), float4(0,0,0,0), float4(0,0,0,0),
                        shadow_oblique_cutoff, surf_diff_colour, normal_ws, surf_specular, normalised_cam_dist, gloss);

        float scene_dist = length(normalised_cam_dist * ray);

        float fragment_dist = length(camera_to_fragment);
        float part_dist = length(camera_to_part);
        float fragment_front_dist = length(camera_to_fragment_front);

        float part_exposed = clamp((scene_dist - fragment_front_dist)/(fragment_dist - fragment_front_dist), 0.0, 1.0);

        float4 texel = tex2D(ptex, part_uv);
        texel.a *= alpha;
        if (texel.a < alpha_rej) discard;
        texel.rgb = pow(texel.rgb, 2.2); // gamma correct texture


        pixel = texel;
        pixel.rgb *= colour;
        //pixel = zero(pixel) + float4(1,0,0,1);
        //pixel.a = 1;
        //pixel.rgb = mod(fragment_dist, 1) * float3(1,1,1);

        float fog_weakness_ = fog_weakness(the_fog_params.x, part_dist);
        // mask alpha by fog
        pixel.a *= one(fog_weakness_);
        // make colour tend towards fog
        //pixel.rgb = lerp(the_fog_colour, pixel.rgb, fog_weakness_);
        pixel.r += zero(alpha_rej) + zero(the_fog_params.r) + zero(the_fog_colour.r) + zero(scene_dist) + zero(camera_pos_ws.r) + zero(far_clip_distance);
        //pixel = zero(pixel) + float4(1,0,0,1);

        #if ALPHA_BLEND == 0
        pixel /= pixel.a;
        #endif
        pixel *= part_exposed;
}

// vim: ts=8:sw=8:et
