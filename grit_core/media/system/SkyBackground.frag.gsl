val polar_rad_x = mod(atan2(pos_ws.x, pos_ws.y) + 2*PI, 2*PI);
val polar_rad_y = atan(pos_ws.z / sqrt(dot(pos_ws.xy, pos_ws.xy)));
val az = polar_rad_x / PI * 180;
val el = polar_rad_y / PI * 180;
val polar_ = Float2(az,el);

if (el <= 0.0) {
    frag.colour.rgb = global.hellColour;
    return;
}




// need to do these in fragment shader, to stop the sun vanishing at the corners of the
// screen
val pos_ss_ = frag.screen.xy/global.viewportSize.xy*2-1;
// TODO: figure out this d3d9 business
//pos_ss_.y *= -d3d9();

// SUN GLARE
var rel_polar = sun_pos_ss_polar.xy - polar_.xy;

// ensure range is within -180 and 180
if (rel_polar.x > 180) rel_polar.x = rel_polar.x - 360;
if (rel_polar.x < -180) rel_polar.x = rel_polar.x + 360;

// debug crosshairs for polar coords
//if (abs(rel_polar.x) < 3) frag.colour.rgb = Float3(1,1,0);
//if (abs(rel_polar.y) < 3) frag.colour.rgb = Float3(1,0,0);

// debug for drawing sun location
//if (dot(rel_polar, rel_polar) < 10*10) frag.colour.rgb *= Float3(1,1,0);

// sunnyness is the amount this sky pixel is affected by the sun
var sunnyness = 0.0;
{
    // needs max to avoid a big reflection on far side of the skysphere
    val qty = max(0, - (rel_polar.x-90)/90 * (rel_polar.x+90)/90 - el / global.skyGlareHorizonElevation);
    sunnyness = min(qty*qty, 1);
}

{
    var r = pow(dot(rel_polar/global.skyGlareSunDistance, rel_polar/global.skyGlareSunDistance), 0.1);
    r = min(r,2);
    sunnyness = clamp(sunnyness + (cos(r*PI/2)+1)/2, 0, 1);
}

// STARFIELD
val tex_coord_ddx = ddx(uv);
val tex_coord_ddy = ddy(uv);
frag.colour.rgb = mat.starfieldMask * gamma_decode(sample2D(mat.starfieldMap, uv, tex_coord_ddx, tex_coord_ddy).rgb);

// SKY GRADIENT
var sky = Float3(0, 0, 0);
var ssky = Float3(0, 0, 0);
if (el < global.skyDivider1) {
    sky  = lerp(global.skyColour0,  global.skyColour1,  (el-0)/(global.skyDivider1-0));
    ssky = lerp(global.skySunColour0, global.skySunColour1, (el-0)/(global.skyDivider1-0));
} else if (el < global.skyDivider2) {
    sky  = lerp(global.skyColour1,  global.skyColour2, (el-global.skyDivider1)/(global.skyDivider2-global.skyDivider1));
    ssky = lerp(global.skySunColour1, global.skySunColour2, (el-global.skyDivider1)/(global.skyDivider2-global.skyDivider1));
} else if (el < global.skyDivider3) {
    sky  = lerp(global.skyColour2,  global.skyColour3, (el-global.skyDivider2)/(global.skyDivider3-global.skyDivider2));
    ssky = lerp(global.skySunColour2, global.skySunColour3, (el-global.skyDivider2)/(global.skyDivider3-global.skyDivider2));
} else if (el < global.skyDivider4) {
    sky  = lerp(global.skyColour3,  global.skyColour4, (el-global.skyDivider3)/(global.skyDivider4-global.skyDivider3));
    ssky = lerp(global.skySunColour3, global.skySunColour4, (el-global.skyDivider3)/(global.skyDivider4-global.skyDivider3));
} else if (el <= 90) {
    sky  = lerp(global.skyColour4,  global.skyColour5,  (el-global.skyDivider4)/(90-global.skyDivider4));
    ssky  = lerp(global.skySunColour4, global.skyColour5, (el-global.skyDivider4)/(90-global.skyDivider4));
} else {
    sky = Float3(1,1,1);
    ssky = Float3(1,1,1);
}
frag.colour.rgb = frag.colour.rgb + lerp(sky, ssky, sunnyness);




// SUN
if (sunlight_dir_ss.z < 1) {
    var sun_uv = Float2(pos_ss_ - sunlight_dir_ss.xy)/global.sunSize*fov;
    if (el < 0.3 && sun_uv.y < 0 && sun_uv.y > -1) {
        //sun_uv.x *= (el+100)/101;
        sun_uv.y = sun_uv.y + (0.3-el)/5;
    }

    var sun_qty = 1.0;
    var dist_to_sun = dot(sun_uv,sun_uv);
    if (dist_to_sun>=1) {
        dist_to_sun = dist_to_sun / global.sunFalloffDistance;
        dist_to_sun = dist_to_sun + 0.8; // magic number, allows big sun + small fade to look different to small sun + big fade
        sun_qty = clamp(1/dist_to_sun/dist_to_sun, 0.0, 1.0);
    }
    frag.colour.rgb = lerp(frag.colour.rgb, global.sunColour, global.sunAlpha * sun_qty);
}

