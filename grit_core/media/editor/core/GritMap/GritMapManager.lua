------------------------------------------------------------------------------
--  This is the map class, commonly used for "current_map"
--
--  (c) 2014-2015 Augusto P. Moura (augustomoura94@hotmail.com)
--
--  Licensed under the MIT license:
--  http://www.opensource.org/licenses/mit-license.php
------------------------------------------------------------------------------

GritMap = {}
function GritMap.new()
	local self = {
		name = "Map_"..math.random();
		description= "";		
		objects = {};
		file_name = "";
		env_cube = "";
		env_cube_dawn = "";
		env_cube_noon = "";
		env_cube_dusk = "";
		env_cube_dark = "";
		cam_pos = {};
		cam_dir = {};
		author = "";
		
		time = {};
		clock_rate = 0;
		include = {};
	}

	make_instance(self, GritMap)
	return self
end;

function GritMap:applyEnvCube()
	if self.env_cube ~= nil and self.env_cube ~= "" then
		if resource_exists(self.env_cube_dawn) then
			env_cube_dawn = self.env_cube_dawn
		end
		if resource_exists(self.env_cube) then
			gfx_env_cube(0, self.env_cube)
			env_cube_noon = self.env_cube_noon
		end
		if resource_exists(self.env_cube_dusk) then
			env_cube_dusk = self.env_cube_dusk
		end
		if resource_exists(self.env_cube_dark) then
			env_cube_dark = self.env_cube_dark
		end
	end
end

-- all temporary textures are saved inside 'cache/env'
function GritMap:generateEnvCube(pos)
	local current_time = env.secondsSinceMidnight
	local current_clockRate = env.clockRate
	env.clockRate = 0
	
	math.randomseed(os.clock())
	
	-- dawn
	env.secondsSinceMidnight = 6 * 60 * 60
	local tex = GED.directory.."/cache/env/".."myenv_dawn"..math.random(1000)..".envcube.tiff"
	gfx_bake_env_cube(tex, 128, pos, 0.7, vec(0, 0, 0))
	self.env_cube_dawn = "/"..tex

	-- noon/default
	env.secondsSinceMidnight = 12 * 60 * 60
	tex = GED.directory.."/cache/env/".."myenv"..math.random(1000)..".envcube.tiff"
	gfx_bake_env_cube(tex, 128, pos, 0.7, vec(0, 0, 0))
	self.env_cube = "/"..tex
	-- noon use the same as default
	self.env_cube_noon = "/"..tex
	
	-- dusk
	env.secondsSinceMidnight = 18 * 60 * 60
	tex = GED.directory.."/cache/env/".."myenv_dusk"..math.random(1000)..".envcube.tiff"
	gfx_bake_env_cube(tex, 128, pos, 0.7, vec(0, 0, 0))
	self.env_cube_dusk = "/"..tex	

	-- dark
	env.secondsSinceMidnight = 0
	tex = GED.directory.."/cache/env/".."myenv_dark"..math.random(1000)..".envcube.tiff"
	gfx_bake_env_cube(tex, 128, pos, 0.7, vec(0, 0, 0))
	self.env_cube_dark = "/"..tex

	self:applyEnvCube()
	env.secondsSinceMidnight = current_time
	env.clockRate = current_clockRate
end

function GritMap:open(mapfile)
	--object_all_del()

	-- you can create a new map and include a lua that cointains object placements
	local map_ext = mapfile:reverse():match("..."):reverse()
	if map_ext == "lua" then
		include (mapfile)
		self.objects = object_all()
		return true
	elseif map_ext == "lvl" then
		object_all_del()
		safe_include (mapfile)
		if gritmap == nil then
			print(RED.."This file is not a Grit Map File")
			return false
		end
		
		if gritmap.name ~= nil then
			self.name = gritmap.name
		end
		if gritmap.author ~= nil then
			self.author = gritmap.author
		end
		if gritmap.description ~= nil then
			self.description = gritmap.description
		end
		if gritmap.clock_rate ~= nil then
			self.clock_rate = gritmap.clock_rate
		end
		
		self.env_cube = gritmap.env_cube or gfx_env_cube(0)
		self.env_cube_dawn = gritmap.env_cube_dawn or env_cube_dawn
		self.env_cube_noon = gritmap.env_cube_noon or env_cube_noon
		self.env_cube_dusk = gritmap.env_cube_dusk or env_cube_dusk
		self.env_cube_dark = gritmap.env_cube_dark or env_cube_dark
		
		self.time = gritmap.time or (12 * 60 * 60)
		self.file_name = mapfile:sub(2)
		
		if gritmap.include ~= nil then
			self.include = gritmap.include
		end
		
		if self.include ~= nil and #self.include > 0 then
			for i = 1, #self.include do
				safe_include(self.include[i])
			end
		end

		if(pcall(gritmap.map) ~= true) then
			print(RED.."ERROR LOADING MAP")
			return false
		end
		self.objects = object_all()
		
		-- self.spawn_point.instance.body.ghost = true
		if in_editor then
			self:setCamera()
		end
		
		env.secondsSinceMidnight = self.time
		self:applyEnvCube()
		env_recompute()
		return true
	else
		print(RED.."File name cannot be handled!")
		return false
	end
end

local function quatPitch(q)
	return math.deg(math.atan2(2*(q.y*q.z + q.w*q.x), q.w*q.w - q.x*q.x - q.y*q.y + q.z*q.z))
end

function GritMap:setCamera()
	self.cam_pos = gritmap.cam_pos or vector3(0, 0, 0)
	self.cam_dir = gritmap.cam_dir or quat(1, 0, 0, 0)
	
	main.camPos = self.cam_pos
	main.camQuat = self.cam_dir

	GED.camPitch = quatPitch(main.camQuat)
	GED.camYaw = cam_yaw_angle()
end

function GritMap:save()
	local file = io.open(self.file_name, "w")

	if file == nil then print(RED.."Could not open file", 1) return false end
	
	-- maybe will be removed, but for now save all objects
	self.objects = object_all()

	file:write(
[[
-- Map file generated by Grit Editor.
-- WARNING: If you modify this file, your changes will be lost if it is
-- subsequently re-saved from editor

gritmap = {
	name = ']]..self.name.."';"..
"\n	author = '"..self.author.."';"..
"\n	description = '"..self.description.."';"..

"\n\n	env_cube = '"..self.env_cube.."';"..
"\n	env_cube_dawn = '"..self.env_cube_dawn.."';"..
"\n	env_cube_noon = '"..self.env_cube_noon.."';"..
"\n	env_cube_dusk = '"..self.env_cube_dusk.."';"..
"\n	env_cube_dark = '"..self.env_cube_dark.."';"..

"\n\n	time = "..env.secondsSinceMidnight..";"..
"\n	clock_rate = "..self.clock_rate..";"

)
	file:write("\n};")
	
	if self.include ~= nil then
		file:write("\n\ngritmap.include = {")
		for i = 1, #self.include do
			file:write("\n	'"..self.include[i].."';")
		end
		file:write("\n};")
	end
	
	file:write("\n\nenv_cycle = ")
	file:write(dump(env_cycle, false))

	file:write("\n\ngritmap.map = function()")
	
	for i = 1, #self.objects do
		-- to save deactivated objects too
		self.objects[i]:activate()
		
		if self.objects[i].editorObject == nil then
			-- reset class name for objects using LOD
			local class_name = self.objects[i].className:gsub("_LOD", "", 1)
			
			file:write("\n")
			-- dump_object_line() not used only because LOD object fix
			-- objects with collision
			if self.objects[i].instance.body ~= nil then
				file:write("object \""..class_name.."\" ("..self.objects[i].instance.body.worldPosition..") {".."rot="..self.objects[i].instance.body.worldOrientation..", name=\""..self.objects[i].name.."\" }")
			-- objects without collision
			elseif self.objects[i].instance.gfx ~= nil then
				file:write("object \""..class_name.."\" ("..self.objects[i].spawnPos..") {".."rot="..self.objects[i].instance.gfx.localOrientation..", name=\""..self.objects[i].name.."\" }")
			-- sounds
			elseif self.objects[i].instance.audio then
				file:write("object \""..class_name.."\" ("..self.objects[i].pos..") {".."orientation="..self.objects[i].orientation..", name=\""..self.objects[i].name.."\" }")
			end
		end
	end
	
	file:write("\nend;\n\n")
	file:write([[
if in_editor ~= nil then
	-- Editor map definitions:]])
	file:write("\n	gritmap.cam_pos = vector3("..main.camPos.x..", "..main.camPos.y..", "..main.camPos.z..")")
	file:write("\n	gritmap.cam_dir = quat("..main.camQuat.w..", "..main.camQuat.x..", "..main.camQuat.y..", "..main.camQuat.z..")")
	file:write("\n\n")
	
	file:write([[
	gritmap.events = {
		
	};
end
	]])
	return file:close()
	
end

function GritMap:export(file_name)
	local file = io.open(file_name, "w")
	print(file_name)
	if file == nil then print(RED.."Could not open file", 1) return false end
	
	-- maybe will be removed, but for now save all objects
	self.objects = object_all()
	
	file:write(
[[
-- Lua file generated by Grit Editor.
-- WARNING: If you modify this file, your changes will be lost if it is subsequently re-saved from editor]]
)
	file:write("\n")
	for i = 1, #self.objects do
		-- to save deactivated objects too
		self.objects[i]:activate()
		
		if self.objects[i].editorObject == nil then
			-- reset class name for objects using LOD
			local class_name = self.objects[i].className:gsub("_LOD", "", 1)
			
			file:write("\n")
			-- dump_object_line() not used only because LOD object fix
			-- objects with collision
			if self.objects[i].instance.body ~= nil then
				file:write("object \""..class_name.."\" ("..self.objects[i].instance.body.worldPosition..") {".."rot="..self.objects[i].instance.body.worldOrientation..", name=\""..self.objects[i].name.."\" }")
			-- objects without collision
			elseif self.objects[i].instance.gfx ~= nil then
				file:write("object \""..class_name.."\" ("..self.objects[i].instance.gfx.localPosition..") {".."rot="..self.objects[i].instance.gfx.localOrientation..", name=\""..self.objects[i].name.."\" }")
			-- sounds
			elseif self.objects[i].instance.audio then
				file:write("object \""..class_name.."\" ("..self.objects[i].pos..") {".."orientation="..self.objects[i].orientation..", name=\""..self.objects[i].name.."\" }")
			end
		end
	end
	
	file:write("\n")
	return file:close()
end
