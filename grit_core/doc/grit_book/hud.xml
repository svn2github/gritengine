<?xml version="1.0" encoding="UTF-8"?>

<section title="The Heads Up Display (HUD)" id="gfx_hud">

    The <def>heads up display</def> (HUD) is a 2D framework for providing a
    graphical user interface to the player.  Like everything else, it can
    be extensively customised via Lua.  The most basic API allows
    positioning and rotating text / textured rectangles in a
    scenegraph-like hierarchy on the screen.  On top of this, various
    widgets have been implemented in Lua, and you are free to make your own
    as well.  The HUD subsystem is designed to handle things like
    health/ammo displays, minimaps, menu screens, and general purpose
    mouse-driven graphical user interfaces.

    <section title="Basics" id="gfx_hud_basics">

        Let us first instantiate an existing class.  The <def>Rect</def>
        HUD class is the simplest class it is possible to write, as it has
        no user-defined behaviours.  Its one-line definition is in the
        common/hud directory, but you can also define your own.
        Instantiate it as follows:

        <lua>
            obj = gfx_hud_obj_make("Rect")
            obj.position = vec(100,100)
            obj.texture = "Icon.png"
            obj.size = vec(50,50)
            obj.orientation = 44
            -- Can also initialise members with a table param:
            obj = gfx_hud_obj_make("Rect", {position = vec(50,50), ...})
        </lua>

        The HUD object has a number of attributes that define how it is
        rendered.  Some examples of these are above, and they are
        comprehensively documented <todo>here</todo>.  If not given, they
        fall back to defaults first in the HUD class and then system
        defaults.

        To begin, we define a <def>HUD class</def>, which has fields and
        methods much like a game class.  The HUD class can be instantiated into
        as many <def>HUD objects</def> as we want.  Without any Lua scripting,
        a HUD object is simply a rectangle drawn on the screen:
        
        <lua>
            hud_class "Icon" {
                texture = "Icon.png";
                colour = vec(0, 1, 1); -- cyan
            }
            obj = gfx_hud_obj_make("Icon", { alpha = 0.5, zOrder = 2 })
            obj.position = vec(100,100)
            obj.size = vec(50,50)
            obj.orientation = 44
            ...
            obj:destroy()
        </lua>

        The HUD object has a number of attributes that define how it is
        rendered.  Some examples of these are above, and they are
        comprehensively documented <todo>here</todo>.  They can be assigned at
        any time, or provided in the class as defaults, or given in the second
        parameter table of gfx_hud_obj_make.  This latter case is simply a
        convenient shorthand for assigning them individually, immediately after
        construction.

        In this case, the 50% alpha-blended, cyan-masked texture will be
        centered at vec(100,100) from the bottom left of the screen and will be
        50 pixels tall and wide.  The orientation attribute rotates the HUD
        object 44 degrees clockwise about its centre.  The zOrder field is an
        integer between 0 and 7 inclusive.  This controls the draw order, with
        7 being on top at 0 being at the bottom.

        The object is automatically garbage collected when it is no-longer
        reachable, but can be destroyed earlier using the destroy method.

    </section>

    <section title="Text" id="gfx_hud_text">

        The text widget allows 

    </section>
    
    <section title="The Hierarchy" id="gfx_hud_tree">
    
    Let us now define something more interesting.  This class has a frame
    callback and a child object -- a text body.

    <lua>
        hud_class "SpinningIcon" {
            texture = "Icon.png";
            myField = true; -- user variables are allowed
            init = function (self)
                self.needsFrameCallbacks = true
                self.myField = false
                -- create a child
                self.child = gfx_hud_text_add("/common/fonts/Verdana12")
                self.child.parent = self
                self.child.text = "Grit!"
            end;
            destroy = function (self)
                -- nothing to do
            end;
            frameCallback = function(self, elapsed)
                self.orientation = (self.orientation + 10*elapsed) % 360
            end;
        }
    </lua>

    This simple example will draw a cyan-tinted rectangle in the bottomn
    left of the screen, that will rotate clockwise about its centre at 10
    degrees per second.  All of the fields that define the HUD object's
    appearance can be given in the class, in the table given in the second
    parameter of gfx_hud_obj_make (which overrides the class values), or at
    any time after construction using regular field assignment.

    The object that we just created has a child object.  This relationship
    was established by setting its parent field.  HUD text is truly a
    primitive entity - it cannot have user-defined fields, have callbacks,
    or be a parent.  A tree is thus formed, with HUD objects at the nodes,
    and either HUD objects or HUD text at the leaves.  We will discuss text
    in greater deal, shortly.
    
    As the icon rotates, the text rotates with it.  Orientation and
    position are applied to children, although inheritOrientation can be
    set to false to suppress the inheriting of orientation.  This can be
    useful e.g. to avoid icons rotating within a spinning minimap / radar
    display.
    
    In this case, a frame callback is used to adjust the orientation.  The
    callback is only called if needsFrameCallbacks is set to true.



    </section>
    

    
</section>
