<chapter title="Graphics" id="graphics">

<section title="Overview" id="gfx_overview">

</section>

<section title="Graphics Bodies" id="gfx_body">

</section>

<section title="Realtime Shadow Techniques Used By Grit" id="gfx_shadow">

    <section title="Depth Shadow Mapping" id="gfx_shadow_dsm">

        Grit has full dynamic shadows that are calculated in real time on the
GPU. The basic technique is called <web
url="http://en.wikipedia.org/wiki/Shadow_mapping">depth shadow mapping</web>.
It involves rendering the scene from the light (the sun or the moon) into a
texture, called a 'shadow map'. The shadow map is updated every frame, because
objects move and so does the light.  However the colour of the scene is
ignored, we are only interested in the depth of everything visible from the
light, i.e. the distance from the light to its nearest occluder in all
directions. When the scene is rendered from the player's point of view, this
shadow map is used as a reference to help decide if a given pixel is the
closest one to the light (in which case it is not in shadow) or whether there
is something else that is closer (in which case it is rendered darker because
it is in shadow).

    </section>

    <section title="Perspective Transform" id="gfx_shadow_lispsm">

        There is a perspective transform applied in order to concentrate as
many of the shadow map's texels as possible in the area nearest the player.
There are many techniques but the one used in Grit is called LiSPSM (<web
url="http://www.cg.tuwien.ac.at/research/vr/lispsm/">LIght Space Perspective
Shadow Mapping</web>). The worst case is when the sun is directly behind you,
in which case no perspective transform can be applied, and the shadow is very
low detail and noisy. If you look 90 degrees to the sun direction however, the
shadows will be a lot crisper due to the use of LiSPSM.  Note that increasing
the resolution of the shadow map texture will also make the shadows crisper,
but will cost memory and performance.

        The perspective transform changes every frame depending on the
light direction and the chase cam's direction. Sometimes the changes can be
quite severe. This causes an unavoidable 'crawling' effect in the shadows.

    </section>

    <section title="Covering Larger Distances" id="gfx_shadow_pssm">

        There are in fact 3 shadow maps used. One for the area closest to the
player, one to cover the area further away, and the 3rd one for the furthest
reach of the shadow (200 metres). They are all the same size textures, but the
one nearest to the camera covers a much smaller area and thus the shadows are
better defined. Another way of looking at this is that it allows shadows to
appear much further from the player, without compromising the quality of
shadows near the player. The exact technique used in Grit is called PSSM <web
url="http://http.developer.nvidia.com/GPUGems3/gpugems3_ch10.html">Parallel
Split Shadow Mapping</web>. Sometimes you can see the transition from one
shadow map to the next, as a sudden decrease in shadow quality.

    </section>

    <section title="Soft Shadows" id="gfx_shadow_pcf">

        If each screen pixel was merely tested for being in shadow or not, the
shadows would be very hard-edged because of the sudden transition from 'in
shadow' to 'not in shadow'. To avoid this, we soften the shadows using a
technique called PCF (<web
url="http://http.developer.nvidia.com/GPUGems/gpugems_ch11.html">Percentage
Closer Filtering</web>) . This boils down to testing the shadow map several times
per screen pixel, and taking the average.  The appearance is that several faint
shadows have been overlaid in slightly different positions, to produce a
blurred effect. It can get very slow but there is hardware support that we are
currently not using that can help, see <issue id="125"/>.

    </section>

</section>

<section title="Shadow Artefacts" id="gfx_shadow_artefacts">

    There are certain things that can go wrong with dynamic shadow
implementations like the ones used in Grit. There are some things to avoid when
modelling objects, in order to avoid problems.

    <section title="Holes in shadows" id="gfx_shadow_holes">

        Since the shadows are calculated by rendering the scene from the sun
(or moon) you have to make sure that your geometry, when viewed from this
direction, appears to be opaque. This means cliffs must have polygons around
the back facing the sun, in order to the sun shining through them to the front.
A more expensive alternative is to turn on the rendering of backfaces in the
material.

        If your map is an island that drops below sealevel in all directions,
you don't have to worry about this.  But if your map is surrounded by some sort
of "wall", then you do.

    </section>

    <section title="Shadow Texture Stretch" id="gfx_shadow_stretch">

        <image src="shadow_stretch.png" caption="Shadow texture stretch occurs
where polys are not facing the light." title="Using SHADOWYNESS" />

        Since the shadow texture is projected onto the scene from the light,
surfaces that are perpendicular to the light (e.g. flat ground at sunset) will
experience very bad texture stretch. This causes aliasing artefacts. Because of
the LiSPSM perspective transformation, the artefacts have a very nasty sawtooth
appearance, instead of the square pixelation that usually occurs with aliasing
artefacts.

        To visualise the aliasing, we can use the following, which renders just
the projection of the shadow map onto the scene, with equal intensitity for all
triangles:

        <lua> debug_cfg.falseColour = "SHADOWYNESS" </lua>

        A small fern on the edge of a cliff is projecting a shadow downhill
away from the edge of the cliff.  The shadow is very elongated because of the
low sun.  One can see the sawtooth artefacts in the stretched part of the
shadow.  When animated, the moving sun causes these sawtooth artefacts to crawl
in a very distracting way.

        <image src="shadow_stretched_hidden.png" caption="Shadow texture stretch is
usually hidden by the lighting equation." title="Using SHADOW_MASK" />

        Luckily these areas should receive very much light due to the diffuse
lighting equation. E.g. if the light is incident at 15 degrees then the amount
of lighting would only be 25% (i.e. sin(15)) of the amount of light that it
would receive at 90 degrees. This means the shadow is much less distinct in
these areas. The following falseColour value shows the actual shadow, i.e.
incorporating the diffuse lighting component as well as the shadow map:

        <lua>debug_cfg.falseColour = "SHADOW_MASK"</lua>

    </section>

    <section title="Normal Bending" id="gfx_shadow_bending">

        If your mesh has sharp edges between polys (an angle of more than 20
degrees for example) and is smooth shaded, then for some pixels, the normals
interpolated across that mesh will be considerably different to the 'true'
normal of that face (i.e. the normal you would calculate using the positions of
the 3 vertexes).  For example, if you model a cube and use smooth shading then
the normal of each face will be orthogonal, but the normals will be smoothly
interpolated around the cube causing a huge amount of normal bending at the
edges and corners.

        <image src="shadow_artefacts.png" caption="Shadow artefacts caused by
normal bending." title="Normal Bending" />

        Normal bending is usually OK, but causes a problem with shadows. This
is because shadow stretch occurs in places where the true normal of the polygon
is close to perpendicular to the light source.  However light attenuation uses
the interpolated normal, which can be pointing closer to the light than the
true normal.  This kind of artefact often occurs on sharp terrain like cliffs.
It causes areas to be subject to lighting that would not ordinarily be lit, and
therefore causes shadow artefacts to appear that would ordinarily be hidden in
the darkness. If the face is in-line with the light, e.g. cliffs at noon, and
there is significant normal bending, then the polygon may be almost fully lit,
even though the polygon is nearly at 90 degrees to the sun.

        The best fix for this is to model in a way that does not have such
extreme smoothing of the normals. However to avoid explosion of polycount,
there is also an alternative - the shadowObliqueCutOff material property.
<!-- â€” -->

        <image src="shadow_artefacts_fixed.png" caption="Here,
shadowObliqueCutoff is set to 20 degrees." title="Normal Bending" />

    </section>

    <section title="Shadow Acne" id="gfx_shadow_acne">

        Imprecision in the shadow map, which records the distance of each
occluder from the light, causes the shadow to fluctuate, causing unpleasant
high frequency transitions from 'in shadow' to 'not in shadow' on every
surface. The engine will avoid shadow acne by adding a certain amount of bias
to the shadow. Thus the shadow is pushed away from the light by enough in order
to avoid the noise being an issue.

        <image src="shadow_acne_example.png" caption="" title="Shadow Acne" />

        The following diagram illustrates the problem, in the case of a wall
standing on flat ground, viewed as a cross-section.

        <image src="shadow_acne_diagram.png" caption="" title="Shadow Acne Diagram" />

        You don't need to worry about this as a modeller, as the engine handles
it internally. However, you should be aware that there is a bias applied to the
shadow by the engine in order to avoid it.

    </section>

    <section title="Additional Bias" id="gfx_shadow_bias">

        You can add additional bias yourself, in the material, in order to get
rid of other artefacts. For example here there are unwanted shadows on the
tank. There is simply not enough fidelity in the dynamic shadows to do this
well enough. We would rather there were no shadows at all.

        <image src="shadow_unwanted.png" caption="" title="Unwanted Shadow Fidelity" />

        One way to avoid this is to avoid these kind of nooks and crannies in
the geometry of the object. However since these contribute greatly to the
appearance of objects, we would prefer some other solution. We can add another
0.1m to the bias in order to push the shadow far enough away from the object to
hide shadows on the high detail parts of the mesh.

        <image src="shadow_unwanted_fixed.png" caption="" title="Manual Bias" />

    </section>

    <section title="Shadow Disconnection" id="gfx_shadow_discon">

        Too much bias can cause a problem in itself though. If the bias is
increased enough, the shadow will move so far from the object that there will
be a 'gap' where the object meets the ground. This gives the unwelcome
appearance that the object is 'floating' above the ground. This is also
illustrated in the above diagram.

        <image src="shadow_disconnection.png" caption="" title="Shadow Disconnection" />

        The bias automatically used by the engine is carefully chosen to be as
small as it can be. However as a modeller you must also make sure your
additional bias is not too large as well.

    </section>

</section>

<section title="Sky Bodies" id="gfx_sky_body" />

<section title="Materials" id="gfx_material" />

<section title="Lights" id="gfx_light" />

<section title="Particles" id="gfx_particle" />

<section title="The HUD" id="gfx_hud">

</section>

<section title="Fonts" id="gfx_font" />

</chapter>

