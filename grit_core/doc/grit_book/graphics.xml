<?xml version="1.0" encoding="UTF-8"?>

<section title="Graphics" id="graphics" splitbelow="true">

    The graphics subsystem is the largest, and its API gives control over
    everything you see on the screen.  This includes objects, particles, and
    lights in the graphics world.  It also includes the heads up display (HUD)
    and fonts.

    <section title="Graphics Bodies" id="gfx_body">

        <section title="Materials" id="gfx_material">

        </section>

    </section>

    <section title="Realtime Shadow Techniques Used By Grit" id="gfx_shadow">

        <section title="Depth Shadow Mapping" id="gfx_shadow_dsm">

            Grit has fully dynamic shadows that are calculated in real time on
            the GPU. The basic technique is called <web
            url="http://en.wikipedia.org/wiki/Shadow_mapping">depth shadow
            mapping</web>.  It involves rendering the scene from the light (the
            sun or the moon) into a texture, called a <def>depth shadow
            map</def>. The shadow map is updated every frame, because objects
            move and so does the light.  The colour of the scene is not
            computed, as we are only interested in the distance to all the
            surfaces that the light can 'see' (these are the occluders).

            When the scene is rendered from the player's point of view, this
            shadow map is used as a reference to help decide if a given pixel
            is the closest one to the light (in which case it is not in shadow)
            or whether there is something else that is closer (in which case it
            is rendered darker because it is in shadow).

        </section>

        <section title="Perspective Transform" id="gfx_shadow_lispsm">

            The depth shadow map has a limited resolution, so in order to
            increase the apparent fidelity (and avoid blocky artefacts) there
            is a perspective transform applied in order to concentrate as many
            as possible of the shadow map's texels close to the player.  There
            are many techniques but the one used in Grit is called LiSPSM (<web
            url="http://www.cg.tuwien.ac.at/research/vr/lispsm/">LIght Space
            Perspective Shadow Mapping</web>).  The worst case is when the sun
            is directly behind you, in which case no perspective transform can
            be applied, and the shadow is very low detail and noisy.  However,
            if you look 90 degrees to the sun, the shadows will be a lot
            crisper due to the use of LiSPSM.  Note that increasing the
            resolution of the shadow map texture will also make the shadows
            crisper, but will cost memory and performance.

            The perspective transform changes every frame depending on the
            light direction and the chase cam's direction. Sometimes the
            changes can be quite severe. This causes an unavoidable 'crawling'
            effect in the shadows.

        </section>

        <section title="Covering Larger Distances" id="gfx_shadow_pssm">

            There are in fact 3 shadow maps used. One for the area closest to
            the player, one to cover the area further away, and the 3rd one for
            the furthest reach of the shadow (200 metres). They are all the
            same size textures, but the one nearest to the camera covers a much
            smaller area and thus the shadows are better defined. Another way
            of looking at this is that it allows shadows to appear much further
            from the player, without compromising the quality of shadows near
            the player. The exact technique used in Grit is called PSSM (<web
            url="http://http.developer.nvidia.com/GPUGems3/gpugems3_ch10.html">Parallel
            Split Shadow Mapping</web>). Sometimes you can see the transition
            from one shadow map to the next, as a sudden decrease in shadow
            quality.

        </section>

        <section title="Soft Shadows" id="gfx_shadow_pcf">

            If each screen pixel was merely tested for being in shadow or not,
            the shadows would be very hard-edged because of the sudden
            transition from 'in shadow' to 'not in shadow'. To avoid this, we
            soften the shadows using a technique called PCF (<web
            url="http://http.developer.nvidia.com/GPUGems/gpugems_ch11.html">Percentage
            Closer Filtering</web>) . This boils down to testing the shadow map
            several times per screen pixel, and taking the average.  The
            appearance is that several faint shadows have been overlaid in
            slightly different positions, to produce a blurred effect. It can
            get very slow but there is hardware support that we are currently
            not using that can help, see <issue id="125"/>.

        </section>

    </section>

    <section title="Shadow Artefacts" id="gfx_shadow_artefacts">

        There are certain things that can go wrong with dynamic shadow
        implementations like the ones used in Grit. There are some things to
        avoid when modelling objects, in order to avoid problems.

        <section title="Holes in shadows" id="gfx_shadow_holes">

            Since the shadows are calculated by rendering the scene from the
            sun (or moon) you have to make sure that your geometry, when viewed
            from this direction, appears to be opaque. This means cliffs must
            have polygons around the back facing the sun, in order to the sun
            shining through them to the front.  A more expensive alternative is
            to turn on the rendering of backfaces in the material.

            If your map is an island that drops below sealevel in all
            directions, you don't have to worry about this.  But if your map is
            surrounded by some sort of "wall", then you do.

        </section>

        <section title="Shadow Texture Stretch" id="gfx_shadow_stretch">

            <image src="shadow_stretch.png" title="Using SHADOWYNESS">
                Shadow texture stretch occurs where polygons do not face the
                light.
            </image>

            Since the shadow texture is projected onto the scene from the
            light, surfaces that are perpendicular to the light (e.g. flat
            ground at sunset) will experience very bad texture stretch. This
            causes aliasing artefacts. Because of the LiSPSM perspective
            transformation, the artefacts have a very nasty sawtooth
            appearance, instead of the square pixelation that usually occurs
            with aliasing artefacts.

            To visualise the aliasing, we can use the following, which renders
            just the projection of the shadow map onto the scene, with equal
            intensitity for all triangles:

            <lua>
                debug_cfg.falseColour = "SHADOWYNESS"
            </lua>

            A small fern on the edge of a cliff is projecting a shadow downhill
            away from the edge of the cliff.  The shadow is very elongated
            because of the low sun.  One can see the sawtooth artefacts in the
            stretched part of the shadow.  When animated, the moving sun causes
            these sawtooth artefacts to crawl in a very distracting way.

            <image src="shadow_stretched_hidden.png" title="Using SHADOW_MASK">
            Shadow texture stretch is usually hidden by the lighting equation.
            </image>

            Luckily these areas should receive very much light due to the
            diffuse lighting equation. E.g. if the light is incident at 15
            degrees then the amount of lighting would only be 25% (i.e.
            sin(15)) of the amount of light that it would receive at 90
            degrees. This means the shadow is much less distinct in these
            areas. The following falseColour value shows the actual shadow,
            i.e.  incorporating the diffuse lighting component as well as the
            shadow map:

            <lua>
                debug_cfg.falseColour = "SHADOW_MASK"
            </lua>

            In the next section, we can see how this effect can be disrupted by
            certain kinds of assets.

        </section>

        <section title="Normal Bending" id="gfx_shadow_bending">

            If your mesh has sharp edges between polys (an angle of more than
            20 degrees for example) and is smooth shaded, then for some pixels,
            the normals interpolated across that mesh will be considerably
            different to the 'true' normal of that face (i.e. the normal you
            would calculate using the positions of the 3 vertexes).  For
            example, if you model a cube and use smooth shading then the
            normals of each face will be orthogonal, but the normals will be
            smoothly interpolated around the cube causing a huge amount of
            normal bending at the edges and corners.

            <image src="shadow_artefacts.png" title="Normal Bending">
            Shadow artefacts caused by normal bending.
            </image>

            Normal bending is usually OK, but causes a problem with shadows.
            This is because shadow stretch occurs in places where the true
            normal of the polygon is close to perpendicular to the light
            source, however light attenuation uses the interpolated normal,
            which can be pointing closer to the light than the true normal.
            This kind of artefact often occurs on sharp terrain like cliffs.
            It causes areas to be illuminated when they would not otherwise be,
            and therefore causes shadow artefacts to appear that would
            ordinarily be hidden in the darkness. If the face is in-line with
            the light, e.g. cliffs at noon, and there is significant normal
            bending, then the polygon may be almost fully lit, even though the
            polygon is nearly at 90 degrees to the sun.

            There used to be a material property <def>shadowObliqueCutoff</def>
            for controlling this effect, but it is no-longer implemented since
            the switch to deferred shading.  The technique was to attenuate
            shadows more aggressively on surfaces rendered with the material in
            question.  However doing this on a per-material basis causes areas
            of the mesh that do not have normal bending to be subject to the
            same attenuation of shadows.  The preferred solution is to
            calculate the amount the amount required at each vertex and store
            that in the vertex as an attribute.  This can be fully automated in
            the asset generation pipeline.  However it is not yet implemented.
            Please ignore the artifacts for now.

        </section>

        <section title="Shadow Acne" id="gfx_shadow_acne">

            <image src="shadow_acne_diagram.png" title="Shadow Acne Diagram">
            An illustration of shadow acne.
            </image>

            Imprecision in the shadow map, which records the distance of each
            occluder from the light, causes the shadow to fluctuate, causing
            unpleasant high frequency transitions from 'in shadow' to 'not in
            shadow' on every surface that faces the light. The engine will
            avoid shadow acne by adding a certain amount of bias to the depth
            of hte caster during the shadow casting phase.  Thus, the shadow is
            pushed away from the light by enough in order to avoid the noise
            being an issue.  The following image illustrates the problem and
            how the depth bias solves it, the screen shot is of a natural gas
            tank, but the diagram below is for a wall on flat ground.

            The engine tries to use the minimal amonut of bias to avoid shadow
            acne, by using the normal of the casting surface and a small
            constant offset on everything.  Thus, you don't need to worry about
            this as a modeller, unless your surfaces are so thin that even this
            small amount of bias is too much.

        </section>

        <section title="Additional Bias" id="gfx_shadow_bias">

            <image src="shadow_unwanted.png" title="Unwanted Shadow Fidelity">
            Unwanted self-shadowing.
            </image>

            You can add additional bias yourself, in the material, in order to
            get rid of other artefacts. For example here there are unwanted
            shadows on the tank. There is simply not enough fidelity in the
            dynamic shadows to properly render shdaows for such detailed
            geometry.  We would rather there were no shadows at all.

            One way to avoid this is to avoid these kind of nooks and crannies
            in the geometry of the object. However since these contribute
            greatly to the appearance of objects, this may be unacceptable.
            Another solution is to add another 0.1m to the depth bias during
            shadow casting (on top of the small amount calculated by the
            engine), in order to push the shadow far enough away from the
            object to hide shadows on the high detail parts of the mesh.

        </section>

        <section title="Shadow Disconnection" id="gfx_shadow_discon">

            <image src="shadow_disconnection.png" title="Shadow Disconnection">
                Too much bias causes the shadow to disconnect from the base of
                the object.
            </image>

            Too much bias can cause a problem in itself though. If the bias is
            increased enough, the shadow will move so far from the object that
            there will be a 'gap' where the object meets the ground. This gives
            the unwelcome appearance that the object is 'floating' above the
            ground, as seen with this table.  If you want a lot of bias, you
            may have to thicken the geometry of your model.

            The bias automatically used by the engine is carefully chosen to be
            as small as it can be. However as a modeller you must also make
            sure your additional bias is not too large as well.

        </section>

    </section>

    <section title="Sky Bodies" id="gfx_sky_body">

        The sky is rendered in a special way.  The scene is rendered first,
        including lighting (but not post-processing effects like bloom), and
        then any areas that remain undrawn are filled with the sky.  The sky
        has only emissive lighting, as it is too far away to be affected by
        lights in the scene.  It also does not move, it is always centered at
        the camera.
        
        The sky is composed of a number of layers, composed via alpha blending
        in HDR buffers.  Conceptually, each layer is a <def>Sky Body</def>
        whose polygons either completely or partially surround the camera
        (which is at 0,0,0).  Thus, the body does not have a position like the
        regular gfx body, although it can be rotated.

        Different layers allow the controlling of different effects, e.g. you
        can have a base stars layer, then a moon layer (which you rotate to
        control the position of the moon), followed by a sky layer (with some
        sort of atmospheric colour model), finally followed by clouds.  Each of
        these layers can be enabled/disabled and oriented seprately.

        Each sky body uses a mesh that is exported from a modeller in the usual
        way.  It is typically a cube or sphere, or in the case of sun / moon
        etc, a small billboard.  One can also imagine strips or other shapes
        being used in certain cases, like meteorite belts or jet trails.  The
        polygons all point inwards, towards vec(0,0,0).  The distance of the
        polygons from 0,0,0 can be arbitrary, since the depth buffer is not
        used to control the layering of sky bodies, rather they are layered
        explicitly.  Typically we use about 1 metre because that is easy to
        manipulate in modelling software.
        
        Sky body materials refer to sky materials instead of regular materials.
        Sky materials are defined in a special way, and are not interchangeable
        with regular materials, although they can share textures.  Here is an
        example:

        <lua>
            sky_material "starfield" {
                emissiveMap = "starfield.dds";
            }
        </lua>

        There is currently implemented a prototype for custom sky shaders, that
        interact with the sky materials.  This is going to be changed in future
        to make it easier to use, so we shall not document it here.  Take a
        look at /system/sky.lua if you are curious to see the current state.
        If you need advanced skies now, contact us via IRC or the forums for
        assistance.

        The sky body itself is created as shown below:

        <lua>
            sky_ent = gfx_sky_body_make("MySkyMesh.mesh", 255)
            sky_ent.enabled = true/false -- disable drawing of this layer
            sky_ent.zOrder = 100 -- change z order
            sky_ent.orientation = quat(1,0,0,0)
        </lua>

        The 255 is the z order, an integer between 0 and 255 inclusive.  The
        value of 255 places it behind everything else.  Use lower numbers to
        add more layers on top.  If two sky bodies have the same z order, the
        ordering is undefined.  So don't do that unless you know the polys will
        not overlap.

    </section>

    <section title="Lights" id="gfx_light">

        Lights provide illumination of the scene (beyond that of the sun/moon)
        and also provide a corona sprite.  They exist at a given place in the
        scene and (if set up to be spotlights) can be rotated to light in a
        given direction.  They are implemented using deferred shading, which
        means their performance cost is proportional to the number of screen
        pixels lit by them.  This allows lots of small lights to be rendered
        efficiently.

        The lights are nodes in the scene graph, so can be attached to other
        nodes and have the same fields.  Like graphics bodies, they can be
        individually enabled/disabled and faded.

        <image src="light_diagram.png" title="Light Diagram">
        Illustration of various light fields.
        </image>

        <lua>
            l = gfx_light_make()
            l.localPosition = vec(1, 2, 3)
            l.orientation = quat(1, 0, 0, 0)
            l.diffuseColour = vec(2,2,2) -- note use of HDR
            l.specularColour = vec(2,2,2)
            l.range = 10 -- light extends for 10m
            l.innerAngle = 50  -- see diagram
            l.outerAngle = 60
        </lua>

        The outerAngle must be >= the innerAngle, as shown in the diagram.  If
        the innerAngle is 180, then the light is not directional, so the
        orientation does not matter.  Otherwise it shines in the +Y direction
        unless oriented differently.

        <section title="Coronas" id="coronas">

            If desired, Grit can draw a corona to simulate the blinding effect
            of the light itself.  The corona's size (diameter) must be
            specified, as it defaults to 0 which means no corona.  The corona
            also has its own colour, which you must set otherwise it defaults
            to white. 

            <lua>
                l.coronaSize = 0.3 -- sphere diameter in metres
                l.coronaLocalPosition = vec(0, 0, 0)
                l.coronaColour = vec(1,1,1) -- white
            </lua>

        </section>

    </section>

    <section title="Particles" id="gfx_particle">

    </section>

    <section title="The Heads Up Display (HUD)" id="gfx_hud">

        The <def>heads up display</def> (HUD) is a 2D framework for providing a
        graphical user interface to the player.  Like everything else, it can
        be extensively customised via Lua.  The most basic API allows
        positioning and rotating text / textured rectangles in a
        scenegraph-like hierarchy on the screen.  On top of this, various
        widgets have been implemented in Lua, and you are free to make your own
        as well.  The HUD subsystem is designed to handle things like
        health/ammo displays, minimaps, menu screens, and general purpose
        mouse-driven graphical user interfaces.

        To begin, we define a <def>HUD class</def>, which has fields and
        methods much like a game class.  The HUD class can be instantiated into
        as many <def>HUD objects</def> as we want.  Without any Lua scripting,
        a HUD object is simply a rectangle drawn on the screen:
        
        <lua>
            hud_class "Icon" {
                texture = "Icon.png";
                colour = vec(0, 1, 1); -- cyan
            }
            obj = gfx_hud_obj_make("Icon", { alpha = 0.5, zOrder = 2 })
            obj.position = vec(100,100)
            obj.size = vec(50,50)
            obj.orientation = 44
            ...
            obj:destroy()
        </lua>

        The HUD object has a number of attributes that define how it is
        rendered.  Some examples of these are above, and they are
        comprehensively documented <todo>here</todo>.  They can be assigned at
        any time, or provided in the class as defaults, or given in the second
        parameter table of gfx_hud_obj_make.  This latter case is simply a
        convenient shorthand for assigning them immediately after construction.

        In this case, the drawn, cyan-masked texture will be centered at
        vec(100,100) from the bottom left of the screen and will be 50 pixels
        tall and wide.  The orientation attribute rotates the HUD object 44
        degrees clockwise about its centre.

        The object is automatically garbage collected when it is no-longer
        pointed at, but can be destroyed earlier using the destroy method.
        
        Let us now define something more interesting.  This class has a frame
        callback and a child object -- a text body.

        <lua>
            hud_class "SpinningIcon" {
                texture = "Icon.png";
                myField = true; -- user variables are allowed
                init = function (self)
                    self.needsFrameCallbacks = true
                    self.myField = false
                    -- create a child
                    self.child = gfx_hud_text_add("/common/fonts/Verdana12")
                    self.child.parent = self
                    self.child.text = "Grit!"
                end;
                destroy = function (self)
                    -- nothing to do
                end;
                frameCallback = function(self, elapsed)
                    self.orientation = (self.orientation + 10*elapsed) % 360
                end;
            }
        </lua>

        This simple example will draw a cyan-tinted rectangle in the bottomn
        left of the screen, that will rotate clockwise about its centre at 10
        degrees per second.  All of the fields that define the HUD object's
        appearance can be given in the class, in the table given in the second
        parameter of gfx_hud_obj_make (which overrides the class values), or at
        any time after construction using regular field assignment.

        The object that we just created has a child object.  This relationship
        was established by setting its parent field.  HUD text is truly a
        primitive entity - it cannot have user-defined fields, have callbacks,
        or be a parent.  A tree is thus formed, with HUD objects at the nodes,
        and either HUD objects or HUD text at the leaves.  We will discuss text
        in greater deal, shortly.
        
        As the icon rotates, the text rotates with it.  Orientation and
        position are applied to children, although inheritOrientation can be
        set to false to suppress the inheriting of orientation.  This can be
        useful e.g. to avoid icons rotating within a spinning minimap / radar
        display.
        
        In this case, a frame callback is used to adjust the orientation.  The
        callback is only called if needsFrameCallbacks is set to true.



        

        
    </section>

    <section title="Fonts" id="gfx_font">

    </section>

</section>

