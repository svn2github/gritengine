Types of external objects:


Host

- singleton
- userdata reference created when calling lua __HOOK_* functions
- no gc required beyond the cleaning up of the pointer which is done by lua


Simple e.g. vector3, quaternion, timer

- are allocated by me in a lua binding e.g. _G.vector3(x,y,z)
- are freed by me at __gc
- no cleanup required beyond calling delete
- independent from any other objects


The ideal: leave it as it is, it is currently fine





Owned by Ogre::Root e.g. SceneManager

- allocated by Ogre::Root::createSceneManager(type)
- cleaned up by Ogre::Root::destroySceneManager()
- i keep the reference to the Ogre::Root object in the userdata to facilitate clean-up


Owned by Ogre::SceneManager, e.g. SceneNode, Camera

- allocated by scenemanger.root, which is a singleton, we don't clean it up on __gc
- also allocated by node:createChild() which are cleaned up on __gc
- cleanup is performed by Ogre::SceneManager::destroySceneNode()
- i keep the reference to the Ogre::SceneManager objcet in the userdata, but in the former case the reference contains NULL
- (so we only call destroySceneNode() if the scene manager reference is non-null)
- camera is the same only without the additional complexity of the singleton root
- entities are also the same


Owned by Ogre::RenderWindow e.g. Viewport
- allocated by the RenderWindow which i hold in the host, so this is a host method that calls host->win->addViewport
- cleanup is by the RenderWindow, which identifies the viewport with its z order (which is unique)
- currently i perform no GC at all which is WRONG


There will be a function to get a handle to some object managed by ogre, and
this handle will have a metatable for accessing various members.  But garbage
collection of this handle will not lead to garbage collection of the object it
represents.  It should always be possible to get another handle to the same
object if your old one is garbage collected.  The only caveat is that there
must be a record of all children of a given parent so they can be disabled when
it is.  This means that during gc of an object, you must notify its parents
table so it can be removed from this list.  Children need to phone home.

-need a global map (inside the host)

host
-scnmgr
--scenenode
--camera
--entity
-viewport

each scnmgr contains:
ptr

each scenenode,camera,entity contains:
ptr, scnmgr ptr

each window contains:
ptr

each rendertexture contains:
ptr

each viewport contains:
ptr, rendertarget

the following map is global:
scnmgr address -> (scene_node_map, cameras_map, entities_map, etc)

obj_map : obj_address -> [userdata]

host also contains a viewport_map which is an instance of the obj_map above

when a scene manager gets killed (by lua - only option i'm afraid) then you look it up in the host map and nullify any active scenenodes, cameras, entities, etc.  this requires iteration through the 3 maps, nullifying every userdata at every key.

when the host is instructed to kill off a scene node, scnmgr:destroyNode() or whatever, the scene node table for that scnmgr is used to find the list of userdata for that scene node, and they are nullified.  that key is then deleted from teh scene node table


Reference-counted, e.g. material
- can either be allocated by me or i can get a reference to it from somewhere else
- each lua userdata has a separate shared_ptr instance which contains a
  reference to a centralised referenced counter and a centralised pointer to
  the resource in question
- when each userdata is created, the internal reference counter is incremented
- at __gc, the reference counter is decremented
- when ref counter is 0 the object is actually destroyed but this is unlikely to be caused by __gc unless i created the object in the first place
- however sometimes you can detach an object from ogre but you have to destroy it yourself by __gcing any remaining references.


Ideal: this probably works ok


Tree
R x
R y
R width
R height
R type
*RW visible
R triggerResize
W resize

Text
R reset
R append
R commit
RW text
*RW font
*RW charHeight
R setColourTop
R getColourTop
R setColourBottom
R getColourBottom

Pane
RW material
