-- Copyright (c) The Grit Game Engine authors 2016 (MIT license)

--[[
A Grit map is a data only (new computation) format for storing maps (collections of object
placements) on disk.  It should be possible for a machine to read and output the map again, hence
being a data only format.  Being data-only, it is analogous to JSON, but in the Lua syntax.

On disk, a grit map has the following structure:

return {
  -- Version code to allow breaking compatability.
  version     = 4,

  -- Metadata.
  properties  = {
    author      = "Insert author here",
    description = "Insert description here",
    name        = "Insert name here",
  },

  -- Position when spawning in the editor.
  editor = {
    cam_pos  = vec(0, 0, 0),
    cam_quat = quat(1, 0, 0, 0),
  },

  -- Paths to environmental lighting cubemaps.
  -- Set all to nil for no environmental lighting.
  -- Set all but one to nil for no env cycle.
  env_cubes = {
    dark = `...`,
    dawn = `...`,
    dusk = `...`,
    noon = `...`,
  },

  environment = {
    clock_rate = 0,  -- Rate of passage of time.
    time = 0,  -- Seconds past midnight.
  },

  -- List of objects in the map.
  objects = {
    { 'classname', vec(0, 0, 0), { ... } },
    { 'classname', vec(0, 0, 0), { ... } },
    ...
  }
}
]]


-- Includes include_path in a context where object() is replaced with a trap that saves object
-- instantiation parameters into a table, then prints a gmap to filename containing those objects.
function convert_include_to_map(include_path, filename)
    assert(include_path:sub(1, 1) == '/', ('"%s" did not begin with /'):format(filename))
    assert(include_path:sub(-4, -1) == '.lua', ('"%s" did not end in .lua'):format(filename))
    assert(filename:sub(1, 1) == '/', ('"%s" did not begin with /'):format(filename))
    assert(filename:sub(-5, -1) == '.gmap', ('"%s" did not end in .gmap'):format(filename))

    local file = io.open(filename:sub(2), 'w')
    if file == nil then error('Could not open file') end

    file:write('-- Map file generated by Grit Editor.\n')
    file:write('return {\n')
    file:write('    version = 4,\n')
    file:write('    properties = {\n')
    file:write("        name = 'Insert name here',\n")
    file:write("        author = 'Insert author here',\n")
    file:write("        description = 'Insert description here',\n")
    file:write('    },\n')
    file:write('    editor = {\n')
    file:write(('        cam_pos = vec(%f, %f, %f),\n'):format(unpack(main.camPos)))
    file:write(('        cam_quat = %s,\n'):format(main.camQuat))
    file:write('    },\n')
    file:write('    env_cubes = {\n')
    file:write(("        dawn = %q,\n"):format(env_cube_dawn))
    file:write(("        noon = %q,\n"):format(env_cube_noon))
    file:write(("        dusk = %q,\n"):format(env_cube_dusk))
    file:write(("        dark = %q,\n"):format(env_cube_dark))
    file:write('    },\n')
    file:write('    environment = {\n')
    file:write(('        time = %f,\n'):format(env.secondsSinceMidnight))
    file:write(('        clock_rate = %f,\n'):format(env.clockRate))
    file:write('    },\n')
    file:write('    objects = {\n')

    local obj_off = vec(0, 0, 0)
    local old_offset_exec = offset_exec
    function offset_exec (off, f, ...)
        obj_off = obj_off + off
        f(...)
        obj_off = obj_off - off
    end
    local old_object = object
    function object (class)
        return function (x, y, z)
            local pos
            if type(x) == 'vector3' then
                pos = obj_off + x
            else
                pos = obj_off + vec(x, y, z)
            end
            return function(body)
                file:write('        {\n')
                file:write(('            `%s`,\n'):format(get_relative_path(filename, class)))
                file:write(('            vec(%f, %f, %f),\n'):format(unpack(pos)))
                file:write('            ')
                file:write(table.dump(body, true, 0, 12, false))
                file:write('\n')
                file:write('        },\n')
            end
        end
    end
    include(include_path)
    object = old_object
    offset_exec = old_offset_exec
    
    file:write('    },\n')
    file:write('}\n')
    file:close()

end


-- Take the map and instantiate all the objects.  Useful mainly to call from the console or at game
-- mode initialization time.
function include_map(mapfile)
    local map = include(mapfile)
    local objects = map.objects or {}
    for _, object in ipairs(objects) do
        local class_name, obj_pos, tab = object[1], object[2], object[3] or {}
        local hid = object_add(class_name, obj_pos, tab)
        local lod = class_get(class_name).lod
        if lod == true then
            if class_name:find("/") then
                -- Insert at the beginning of the filename (ignoring the dir path).
                lod = class_name:reverse():gsub("/", "_dol/", 1):reverse()
            else
                lod = "lod_" .. class_name
            end
        end
        if lod then
            if class_get(lod) then
                tab.near = hid
                if tab.name then tab.name = tab.name .. "_lod" end
                object_add(lod, obj_pos, tab)
            else
                error(('Class "%s" referred to a lod class "%s" that does not exist.'):format(class_name, lod))
            end
        end

    end

    env_cube_dawn = map.env_cubes.dawn
    env_cube_noon = map.env_cubes.noon
    env_cube_dusk = map.env_cubes.dusk
    env_cube_dark = map.env_cubes.dark
    env_recompute()
    
    env.secondsSinceMidnight = map.environment.time
    env.clockRate = map.environment.clock_rate
    include(map.environment.env_cycle_file or `/system/env_cycle.lua`)
end

